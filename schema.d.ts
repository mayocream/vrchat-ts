/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/auth/exists": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Check User Exists
         * @description Checks if a user by a given `username`, `displayName` or `email` exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the `excludeUserId` is used to exclude oneself, otherwise the result would always be true.
         *
         *     It is **REQUIRED** to include **AT LEAST** `username`, `displayName` **or** `email` query parameter. Although they can be combined - in addition with `excludeUserId` (generally to exclude yourself) - to further fine-tune the search.
         */
        get: operations["checkUserExists"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/user": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Login and/or Get Current User Info
         * @description This endpoint does the following two operations:
         *       1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.
         *       2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.
         *
         *     The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.
         *
         *     > base64(urlencode(username):urlencode(password))
         *
         *     **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
         */
        get: operations["getCurrentUser"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/twofactorauth/totp/verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Verify 2FA code
         * @description Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
         */
        post: operations["verify2FA"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/twofactorauth/otp/verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Verify 2FA code with Recovery code
         * @description Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
         */
        post: operations["verifyRecoveryCode"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/twofactorauth/emailotp/verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Verify 2FA email code
         * @description Finishes the login sequence with an 2FA email code.
         */
        post: operations["verify2FAEmailCode"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Verify Auth Token
         * @description Verify whether the currently provided Auth Token is valid.
         */
        get: operations["verifyAuthToken"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Logout
         * @description Invalidates the login session.
         */
        put: operations["logout"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{userId}/delete": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * Delete User
         * @description Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.
         *
         *     **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.
         *
         *     **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
         */
        put: operations["deleteUser"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{userId}/avatar": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        /**
         * Get Own Avatar
         * @description Get the current avatar for the user. This will return an error for any other user than the one logged in.
         */
        get: operations["getOwnAvatar"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/avatars": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search Avatars
         * @description Search and list avatars by query filters. You can only search your own or featured avatars. It is not possible as a normal user to search other peoples avatars.
         */
        get: operations["searchAvatars"];
        put?: never;
        /**
         * Create Avatar
         * @description Create an avatar. It's possible to optionally specify a ID if you want a custom one. Attempting to create an Avatar with an already claimed ID will result in a DB error.
         */
        post: operations["createAvatar"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/avatars/{avatarId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid avatar ID. */
                avatarId: components["parameters"]["avatarId"];
            };
            cookie?: never;
        };
        /**
         * Get Avatar
         * @description Get information about a specific Avatar.
         */
        get: operations["getAvatar"];
        /**
         * Update Avatar
         * @description Update information about a specific avatar.
         */
        put: operations["updateAvatar"];
        post?: never;
        /**
         * Delete Avatar
         * @description Delete an avatar. Notice an avatar is never fully "deleted", only its ReleaseStatus is set to "hidden" and the linked Files are deleted. The AvatarID is permanently reserved.
         */
        delete: operations["deleteAvatar"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/avatars/{avatarId}/select": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid avatar ID. */
                avatarId: components["parameters"]["avatarId"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * Select Avatar
         * @description Switches into that avatar.
         */
        put: operations["selectAvatar"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/avatars/{avatarId}/selectFallback": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid avatar ID. */
                avatarId: components["parameters"]["avatarId"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * Select Fallback Avatar
         * @description Switches into that avatar as your fallback avatar.
         */
        put: operations["selectFallbackAvatar"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/avatars/favorites": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Favorited Avatars
         * @description Search and list favorited avatars by query filters.
         */
        get: operations["getFavoritedAvatars"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/Steam/transactions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Steam Transactions
         * @description Get all own Steam transactions.
         */
        get: operations["getSteamTransactions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/Steam/transactions/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid transaction ID. */
                transactionId: components["parameters"]["transactionId"];
            };
            cookie?: never;
        };
        /**
         * Get Steam Transaction
         * @deprecated
         * @description Get a single Steam transactions by ID. This returns the exact same information as `getSteamTransactions`, so no point in using this endpoint.
         */
        get: operations["getSteamTransaction"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/Admin/transactions/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid transaction ID. */
                transactionId: components["parameters"]["transactionId"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/user/subscription": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Current Subscriptions
         * @description Get a list of all current user subscriptions.
         */
        get: operations["getCurrentSubscriptions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/subscriptions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Subscriptions
         * @description List all existing Subscriptions. For example, "vrchatplus-monthly" and "vrchatplus-yearly".
         */
        get: operations["getSubscriptions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/licenseGroups/{licenseGroupId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid license group ID. */
                licenseGroupId: components["parameters"]["licenseGroupId"];
            };
            cookie?: never;
        };
        /**
         * Get License Group
         * @description Get a single License Group by given ID.
         */
        get: operations["getLicenseGroup"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/favorites": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Favorites
         * @description Returns a list of favorites.
         */
        get: operations["getFavorites"];
        put?: never;
        /**
         * Add Favorite
         * @description Add a new favorite.
         *
         *     Friend groups are named `group_0` through `group_3`. Avatar and World groups are named `avatars1` to `avatars4` and `worlds1` to `worlds4`.
         *
         *     You cannot add people whom you are not friends with to your friends list. Destroying a friendship removes the person as favorite on both sides.
         */
        post: operations["addFavorite"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/favorites/{favoriteId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid favorite ID. */
                favoriteId: components["parameters"]["favoriteId"];
            };
            cookie?: never;
        };
        /**
         * Show Favorite
         * @description Return information about a specific Favorite.
         */
        get: operations["getFavorite"];
        put?: never;
        post?: never;
        /**
         * Remove Favorite
         * @description Remove a favorite from your favorites list.
         */
        delete: operations["removeFavorite"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/favorite/groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Favorite Groups
         * @description Return a list of favorite groups owned by a user. Returns the same information as `getFavoriteGroups`.
         */
        get: operations["getFavoriteGroups"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/favorite/group/{favoriteGroupType}/{favoriteGroupName}/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The type of group to fetch, must be a valid FavoriteType. */
                favoriteGroupType: components["parameters"]["favoriteGroupType"];
                /** @description The name of the group to fetch, must be a name of a FavoriteGroup. */
                favoriteGroupName: components["parameters"]["favoriteGroupName"];
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        /**
         * Show Favorite Group
         * @description Fetch information about a specific favorite group.
         */
        get: operations["getFavoriteGroup"];
        /**
         * Update Favorite Group
         * @description Update information about a specific favorite group.
         */
        put: operations["updateFavoriteGroup"];
        post?: never;
        /**
         * Clear Favorite Group
         * @description Clear ALL contents of a specific favorite group.
         */
        delete: operations["clearFavoriteGroup"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/files": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Files
         * @description Returns a list of files
         */
        get: operations["getFiles"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/file": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create File
         * @description Creates a new File object
         */
        post: operations["createFile"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/file/{fileId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid file ID. */
                fileId: components["parameters"]["fileId"];
            };
            cookie?: never;
        };
        /**
         * Show File
         * @description Shows general information about the "File" object. Each File can have several "Version"'s, and each Version can have multiple real files or "Data" blobs.
         */
        get: operations["getFile"];
        put?: never;
        /**
         * Create File Version
         * @description Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
         */
        post: operations["createFileVersion"];
        /**
         * Delete File
         * @description Deletes a File object.
         */
        delete: operations["deleteFile"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/file/{fileId}/{versionId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid file ID. */
                fileId: components["parameters"]["fileId"];
                /** @description Version ID of the asset. */
                versionId: components["parameters"]["versionId"];
            };
            cookie?: never;
        };
        /**
         * Download File Version
         * @description Downloads the file with the provided version number.
         *
         *     **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.
         *
         *     **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
         */
        get: operations["downloadFileVersion"];
        put?: never;
        post?: never;
        /**
         * Delete File Version
         * @description Delete a specific version of a file. You can only delete the latest version.
         */
        delete: operations["deleteFileVersion"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/file/{fileId}/{versionId}/{fileType}/finish": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid file ID. */
                fileId: components["parameters"]["fileId"];
                /** @description Version ID of the asset. */
                versionId: components["parameters"]["versionId"];
                /** @description Type of file. */
                fileType: components["parameters"]["fileType"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * Finish FileData Upload
         * @description Finish an upload of a FileData. This will mark it as "complete". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
         */
        put: operations["finishFileDataUpload"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/file/{fileId}/{versionId}/{fileType}/start": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid file ID. */
                fileId: components["parameters"]["fileId"];
                /** @description Version ID of the asset. */
                versionId: components["parameters"]["versionId"];
                /** @description Type of file. */
                fileType: components["parameters"]["fileType"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * Start FileData Upload
         * @description Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS's REST documentation on "PUT Object to S3" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.
         *
         *     **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
         */
        put: operations["startFileDataUpload"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/file/{fileId}/{versionId}/{fileType}/status": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid file ID. */
                fileId: components["parameters"]["fileId"];
                /** @description Version ID of the asset. */
                versionId: components["parameters"]["versionId"];
                /** @description Type of file. */
                fileType: components["parameters"]["fileType"];
            };
            cookie?: never;
        };
        /**
         * Check FileData Upload Status
         * @description Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
         */
        get: operations["getFileDataUploadStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/user/friends": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Friends
         * @description List information about friends.
         */
        get: operations["getFriends"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/{userId}/friendRequest": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Send Friend Request
         * @description Send a friend request to another user.
         */
        post: operations["friend"];
        /**
         * Delete Friend Request
         * @description Deletes an outgoing pending friend request to another user. To delete an incoming friend request, use the `deleteNotification` endpoint instead.
         */
        delete: operations["deleteFriendRequest"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/{userId}/friendStatus": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        /**
         * Check Friend Status
         * @description Retrieve if the user is currently a friend with a given user, if they have an outgoing friend request, and if they have an incoming friend request. The proper way to receive and accept friend request is by checking if the user has an incoming `Notification` of type `friendRequest`, and then accepting that notification.
         */
        get: operations["getFriendStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/user/friends/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Unfriend
         * @description Unfriend a user by ID.
         */
        delete: operations["unfriend"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search Group
         * @description Searches Groups by name or shortCode
         */
        get: operations["searchGroups"];
        put?: never;
        /**
         * Create Group
         * @description Creates a Group and returns a Group object. **Requires VRC+ Subscription.**
         */
        post: operations["createGroup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        /**
         * Get Group by ID
         * @description Returns a single Group by ID.
         */
        get: operations["getGroup"];
        /**
         * Update Group
         * @description Updates a Group and returns it.
         */
        put: operations["updateGroup"];
        post?: never;
        /**
         * Delete Group
         * @description Deletes a Group.
         */
        delete: operations["deleteGroup"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/announcement": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        /**
         * Get Group Announcement
         * @description Returns the announcement for a Group.
         *     If no announcement has been made, then it returns **empty object**.
         *     If an announcement exists, then it will always return all fields except `imageId` and `imageUrl` which may be null.
         */
        get: operations["getGroupAnnouncements"];
        put?: never;
        /**
         * Create Group Announcement
         * @description Creates an Announcement for a Group.
         */
        post: operations["createGroupAnnouncement"];
        /**
         * Delete Group Announcement
         * @description Deletes the announcement for a Group.
         */
        delete: operations["deleteGroupAnnouncement"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/auditLogs": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        /**
         * Get Group Audit Logs
         * @description Returns a list of audit logs for a Group.
         */
        get: operations["getGroupAuditLogs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/bans": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        /**
         * Get Group Bans
         * @description Returns a list of banned users for a Group.
         */
        get: operations["getGroupBans"];
        put?: never;
        /**
         * Ban Group Member
         * @description Bans a user from a Group.
         */
        post: operations["banGroupMember"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/bans/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Unban Group Member
         * @description Unbans a user from a Group.
         */
        delete: operations["unbanGroupMember"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/galleries": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Group Gallery
         * @description Creates a gallery for a Group.
         */
        post: operations["createGroupGallery"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/galleries/{groupGalleryId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid group gallery ID. */
                groupGalleryId: components["parameters"]["groupGalleryId"];
            };
            cookie?: never;
        };
        /**
         * Get Group Gallery Images
         * @description Returns a list of images for a Group gallery.
         */
        get: operations["getGroupGalleryImages"];
        /**
         * Update Group Gallery
         * @description Updates a gallery for a Group.
         */
        put: operations["updateGroupGallery"];
        post?: never;
        /**
         * Delete Group Gallery
         * @description Deletes a gallery for a Group.
         */
        delete: operations["deleteGroupGallery"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/galleries/{groupGalleryId}/images": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid group gallery ID. */
                groupGalleryId: components["parameters"]["groupGalleryId"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add Group Gallery Image
         * @description Adds an image to a Group gallery.
         */
        post: operations["addGroupGalleryImage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/galleries/{groupGalleryId}/images/{groupGalleryImageId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid group gallery ID. */
                groupGalleryId: components["parameters"]["groupGalleryId"];
                /** @description Must be a valid group gallery image ID. */
                groupGalleryImageId: components["parameters"]["groupGalleryImageId"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete Group Gallery Image
         * @description Deletes an image from a Group gallery.
         */
        delete: operations["deleteGroupGalleryImage"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/instances": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        /**
         * Get Group Instances
         * @description Returns a list of group instances
         */
        get: operations["getGroupInstances"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/invites": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        /**
         * Get Group Invites Sent
         * @description Returns a list of members that have been invited to the Group.
         */
        get: operations["getGroupInvites"];
        put?: never;
        /**
         * Invite User to Group
         * @description Sends an invite to a user to join the group.
         */
        post: operations["createGroupInvite"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/invites/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete User Invite
         * @description Deletes an Group invite sent to a User
         */
        delete: operations["deleteGroupInvite"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/join": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Join Group
         * @description Join a Group by ID and returns the member object.
         */
        post: operations["joinGroup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/leave": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Leave Group
         * @description Leave a group by ID.
         */
        post: operations["leaveGroup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/members": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        /**
         * List Group Members
         * @description Returns a List of all **other** Group Members. This endpoint will never return the user calling the endpoint.
         *     Information about the user calling the endpoint must be found in the `myMember` field of the Group object.
         */
        get: operations["getGroupMembers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/members/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        /**
         * Get Group Member
         * @description Returns a LimitedGroup Member.
         */
        get: operations["getGroupMember"];
        /**
         * Update Group Member
         * @description Updates a Group Member
         */
        put: operations["updateGroupMember"];
        post?: never;
        /**
         * Kick Group Member
         * @description Kicks a Group Member from the Group. The current user must have the "Remove Group Members" permission.
         */
        delete: operations["kickGroupMember"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/members/{userId}/roles/{groupRoleId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
                /** @description Must be a valid group role ID. */
                groupRoleId: components["parameters"]["groupRoleId"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * Add Role to GroupMember
         * @description Adds a Role to a Group Member
         */
        put: operations["addGroupMemberRole"];
        post?: never;
        /**
         * Remove Role from GroupMember
         * @description Removes a Role from a Group Member
         */
        delete: operations["removeGroupMemberRole"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/permissions": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        /**
         * List Group Permissions
         * @description Returns a List of all possible/available permissions for a Group.
         */
        get: operations["getGroupPermissions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/posts": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        /**
         * Get posts from a Group
         * @description Get posts from a Group
         */
        get: operations["getGroupPost"];
        put?: never;
        /**
         * Create a post in a Group
         * @description Create a post in a Group.
         */
        post: operations["addGroupPost"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/posts/{notificationId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid notification ID. */
                notificationId: components["parameters"]["notificationId"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * Edits a Group post
         * @description Edits a Group post
         */
        put: operations["updateGroupPost"];
        post?: never;
        /**
         * Delete a Group post
         * @description Delete a Group post
         */
        delete: operations["deleteGroupPost"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/requests": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        /**
         * Get Group Join Requests
         * @description Returns a list of members that have requested to join the Group.
         */
        get: operations["getGroupRequests"];
        put?: never;
        post?: never;
        /**
         * Cancel Group Join Request
         * @description Cancels a request sent to join the group.
         */
        delete: operations["cancelGroupRequest"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/requests/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * Respond Group Join request
         * @description Responds to a Group Join Request with Accept/Deny
         */
        put: operations["respondGroupJoinRequest"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/roles": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        /**
         * Get Group Roles
         * @description Returns a Group Role by ID.
         */
        get: operations["getGroupRoles"];
        put?: never;
        /**
         * Create GroupRole
         * @description Create a Group role.
         */
        post: operations["createGroupRole"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{groupId}/roles/{groupRoleId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid group role ID. */
                groupRoleId: components["parameters"]["groupRoleId"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * Update Group Role
         * @description Updates a group role by ID.
         */
        put: operations["updateGroupRole"];
        post?: never;
        /**
         * Delete Group Role
         * @description Deletes a Group Role by ID and returns the remaining roles.
         */
        delete: operations["deleteGroupRole"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/invite/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Invite User
         * @description Sends an invite to a user. Returns the Notification of type `invite` that was sent.
         */
        post: operations["inviteUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/invite/myself/to/{worldId}:{instanceId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
                /** @description Must be a valid instance ID. */
                instanceId: components["parameters"]["instanceId"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Invite Myself To Instance
         * @description Sends self an invite to an instance
         */
        post: operations["inviteMyselfTo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/requestInvite/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request Invite
         * @description Requests an invite from a user. Returns the Notification of type `requestInvite` that was sent.
         */
        post: operations["requestInvite"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/invite/{notificationId}/response": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid notification ID. */
                notificationId: components["parameters"]["notificationId"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Respond Invite
         * @description Respond to an invite request by sending a world invite to the requesting user. `:notificationId` is the ID of the requesting notification.
         */
        post: operations["respondInvite"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/message/{userId}/{messageType}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
                /** @description The type of message to fetch, must be a valid InviteMessageType. */
                messageType: components["parameters"]["messageType"];
            };
            cookie?: never;
        };
        /**
         * List Invite Messages
         * @description Returns a list of all the users Invite Messages. Admin Credentials are required to view messages of other users!
         *
         *     Message type refers to a different collection of messages, used during different types of responses.
         *
         *     * `message` = Message during a normal invite
         *     * `response` = Message when replying to a message
         *     * `request` = Message when requesting an invite
         *     * `requestResponse` = Message when replying to a request for invite
         */
        get: operations["getInviteMessages"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/message/{userId}/{messageType}/{slot}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
                /** @description The type of message to fetch, must be a valid InviteMessageType. */
                messageType: components["parameters"]["messageType"];
                /** @description The message slot to fetch of a given message type. */
                slot: components["parameters"]["slot"];
            };
            cookie?: never;
        };
        /**
         * Get Invite Message
         * @description Returns a single Invite Message. This returns the exact same information but less than `getInviteMessages`. Admin Credentials are required to view messages of other users!
         *
         *     Message type refers to a different collection of messages, used during different types of responses.
         *
         *     * `message` = Message during a normal invite
         *     * `response` = Message when replying to a message
         *     * `request` = Message when requesting an invite
         *     * `requestResponse` = Message when replying to a request for invite
         */
        get: operations["getInviteMessage"];
        /**
         * Update Invite Message
         * @description Updates a single Invite Message and then returns a list of all of them. Admin Credentials are required to update messages of other users!
         *
         *     Updating a message automatically sets the cooldown timer to 60 minutes.
         *     Trying to edit a message before the cooldown timer expires results in a 429 "Too Fast Error".
         *
         *     Message type refers to a different collection of messages, used during different types of responses.
         *
         *     * `message` = Message during a normal invite
         *     * `response` = Message when replying to a message
         *     * `request` = Message when requesting an invite
         *     * `requestResponse` = Message when replying to a request for invite
         */
        put: operations["updateInviteMessage"];
        post?: never;
        /**
         * Reset Invite Message
         * @description Resets a single Invite Message back to its original message, and then returns a list of all of them. Admin Credentials are required to update messages of other users!
         *
         *     Resetting a message respects the rate-limit, so it is not possible to reset within the 60 minutes countdown.
         *     Resetting it does however not set the rate-limit to 60 like when editing it.
         *     It is possible to edit it right after resetting it.
         *     Trying to edit a message before the cooldown timer expires results in a 429 "Too Fast Error".
         *
         *     Message type refers to a different collection of messages, used during different types of responses.
         *
         *     * `message` = Message during a normal invite
         *     * `response` = Message when replying to a message
         *     * `request` = Message when requesting an invite
         *     * `requestResponse` = Message when replying to a request for invite
         *
         *     The DELETE endpoint does not have/require any request body.
         */
        delete: operations["resetInviteMessage"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/instances": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Instance
         * @description Create an instance
         */
        post: operations["createInstance"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/instances/{worldId}:{instanceId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
                /** @description Must be a valid instance ID. */
                instanceId: components["parameters"]["instanceId"];
            };
            cookie?: never;
        };
        /**
         * Get Instance
         * @description Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
         *
         *     If an invalid instanceId is provided, this endpoint will simply return "null"!
         */
        get: operations["getInstance"];
        put?: never;
        post?: never;
        /**
         * Close Instance
         * @description Close an instance or update the closedAt time when it will be closed.
         *
         *     You can only close an instance if the ownerId is yourself or if the instance owner is a group and you have the `group-instance-moderate` permission.
         */
        delete: operations["closeInstance"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/instances/{worldId}:{instanceId}/shortName": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
                /** @description Must be a valid instance ID. */
                instanceId: components["parameters"]["instanceId"];
            };
            cookie?: never;
        };
        /**
         * Get Instance Short Name
         * @description Returns an instance short name.
         */
        get: operations["getShortName"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/instances/{worldId}:{instanceId}/invite": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
                /** @description Must be a valid instance ID. */
                instanceId: components["parameters"]["instanceId"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Send Self Invite
         * @description Sends an invite to the instance to yourself.
         */
        post: operations["sendSelfInvite"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/instances/s/{shortName}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid instance short name. */
                shortName: string;
            };
            cookie?: never;
        };
        /**
         * Get Instance By Short Name
         * @description Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
         */
        get: operations["getInstanceByShortName"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/user/notifications": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Notifications
         * @description Retrieve all of the current user's notifications.
         */
        get: operations["getNotifications"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/user/notifications/{notificationId}/accept": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid notification ID. */
                notificationId: components["parameters"]["notificationId"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * Accept Friend Request
         * @description Accept a friend request by notification `frq_` ID. Friend requests can be found using the NotificationsAPI `getNotifications` by filtering of type `friendRequest`.
         */
        put: operations["acceptFriendRequest"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/user/notifications/{notificationId}/see": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid notification ID. */
                notificationId: components["parameters"]["notificationId"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * Mark Notification As Read
         * @description Mark a notification as seen.
         */
        put: operations["markNotificationAsRead"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/user/notifications/{notificationId}/hide": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid notification ID. */
                notificationId: components["parameters"]["notificationId"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * Delete Notification
         * @description Delete a notification.
         */
        put: operations["deleteNotification"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/user/notifications/clear": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Clear All Notifications
         * @description Clear **all** notifications.
         */
        put: operations["clearNotifications"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/permissions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Assigned Permissions
         * @description Returns a list of all permissions currently granted by the user. Permissions are assigned e.g. by subscribing to VRC+.
         */
        get: operations["getAssignedPermissions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/permissions/{permissionId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid permission ID. */
                permissionId: components["parameters"]["permissionId"];
            };
            cookie?: never;
        };
        /**
         * Get Permission
         * @description Returns a single permission. This endpoint is pretty useless, as it returns the exact same information as `/auth/permissions`.
         */
        get: operations["getPermission"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/user/playermoderations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search Player Moderations
         * @description Returns a list of all player moderations made by **you**.
         *
         *     This endpoint does not have pagination, and will return *all* results. Use query parameters to limit your query if needed.
         */
        get: operations["getPlayerModerations"];
        put?: never;
        /**
         * Moderate User
         * @description Moderate a user, e.g. unmute them or show their avatar.
         *
         *     Please see the [Player Moderation docs](https://vrchatapi.github.io/docs/api/#tag--playermoderation) on what playerModerations are, and how they differ from staff moderations.
         */
        post: operations["moderateUser"];
        /**
         * Clear All Player Moderations
         * @description ⚠️ **This will delete every single player moderation you've ever made.**
         */
        delete: operations["clearAllPlayerModerations"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/user/playermoderations/{playerModerationId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid `pmod_` ID. */
                playerModerationId: string;
            };
            cookie?: never;
        };
        /**
         * Get Player Moderation
         * @description Returns a single Player Moderation. This returns the exact same amount of information as the more generalised `getPlayerModerations`.
         */
        get: operations["getPlayerModeration"];
        put?: never;
        post?: never;
        /**
         * Delete Player Moderation
         * @description Deletes a specific player moderation based on it's `pmod_` ID. The website uses `unmoderateUser` instead. You can delete the same player moderation multiple times successfully.
         */
        delete: operations["deletePlayerModeration"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/user/unplayermoderate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Unmoderate User
         * @description Removes a player moderation previously added through `moderateUser`. E.g if you previously have shown their avatar, but now want to reset it to default.
         */
        put: operations["unmoderateUser"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Fetch API Config
         * @description API config contains configuration that the clients needs to work properly.
         *
         *     Currently the most important value here is `clientApiKey` which is used for all other API endpoints.
         */
        get: operations["getConfig"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/infoPush": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Show Information Notices
         * @description IPS (Info Push System) is a system for VRChat to push out dynamic information to the client. This is primarily used by the Quick-Menu info banners, but can also be used to e.g. alert you to update your game to the latest version.
         *
         *     `include` is used to query what Information Pushes should be included in the response. If include is missing or empty, then no notices will normally be returned. This is an "any of" search.
         *
         *     `require` is used to limit what Information Pushes should be included in the response. This is usually used in combination with `include`, and is an "all of" search.
         */
        get: operations["getInfoPush"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/css/app.css": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Download CSS
         * @description Fetches the CSS code to the frontend React website.
         */
        get: operations["getCSS"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/js/app.js": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Download JavaScript
         * @description Fetches the JavaScript code to the frontend React website.
         */
        get: operations["getJavaScript"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Check API Health
         * @deprecated
         * @description ~~Gets the overall health status, the server name, and the current build version tag of the API.~~
         *
         *     **DEPRECATED:** VRChat has suddenly restricted this endpoint for unknown reasons, and now always return 401 Unauthorized.
         */
        get: operations["getHealth"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/visits": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Current Online Users
         * @description Returns the current number of online users.
         *
         *     **NOTE:** The response type is not a JSON object, but a simple JSON integer.
         */
        get: operations["getCurrentOnlineUsers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/time": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Current System Time
         * @description Returns the current time of the API server.
         *
         *     **NOTE:** The response type is not a JSON object, but a simple JSON string.
         */
        get: operations["getSystemTime"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search All Users
         * @description Search and list any users by text query
         */
        get: operations["searchUsers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{username}/name": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Username of the user */
                username: string;
            };
            cookie?: never;
        };
        /**
         * Get User by Username
         * @deprecated
         * @description ~~Get public user information about a specific user using their name.~~
         *
         *     **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
         *     This endpoint now require Admin Credentials.
         */
        get: operations["getUserByName"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{userId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        /**
         * Get User by ID
         * @description Get public user information about a specific user using their ID.
         */
        get: operations["getUser"];
        /**
         * Update User Info
         * @description Update a users information such as the email and birthday.
         */
        put: operations["updateUser"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{userId}/groups": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        /**
         * Get User Groups
         * @description Get user's public groups
         */
        get: operations["getUserGroups"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{userId}/groups/requested": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        /**
         * Get User Group Requests
         * @description Returns a list of Groups the user has requested to be invited into.
         */
        get: operations["getUserGroupRequests"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{userId}/groups/represented": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        /**
         * Get user's current represented group
         * @description Returns the current group that the user is currently representing
         */
        get: operations["getUserRepresentedGroup"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/worlds": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search All Worlds
         * @description Search and list any worlds by query filters.
         */
        get: operations["searchWorlds"];
        put?: never;
        /**
         * Create World
         * @description Create a new world. This endpoint requires `assetUrl` to be a valid File object with `.vrcw` file extension, and `imageUrl` to be a valid File object with an image file extension.
         */
        post: operations["createWorld"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/worlds/active": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Active Worlds
         * @description Search and list currently Active worlds by query filters.
         */
        get: operations["getActiveWorlds"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/worlds/favorites": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Favorited Worlds
         * @description Search and list favorited worlds by query filters.
         */
        get: operations["getFavoritedWorlds"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/worlds/recent": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Recent Worlds
         * @description Search and list recently visited worlds by query filters.
         */
        get: operations["getRecentWorlds"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/worlds/{worldId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
            };
            cookie?: never;
        };
        /**
         * Get World by ID
         * @description Get information about a specific World.
         *     Works unauthenticated but when so will always return `0` for certain fields.
         */
        get: operations["getWorld"];
        /**
         * Update World
         * @description Update information about a specific World.
         */
        put: operations["updateWorld"];
        post?: never;
        /**
         * Delete World
         * @description Delete a world. Notice a world is never fully "deleted", only its ReleaseStatus is set to "hidden" and the linked Files are deleted. The WorldID is permanently reserved.
         */
        delete: operations["deleteWorld"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/worlds/{worldId}/metadata": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
            };
            cookie?: never;
        };
        /**
         * Get World Metadata
         * @deprecated
         * @description Return a worlds custom metadata. This is currently believed to be unused. Metadata can be set with `updateWorld` and can be any arbitrary object.
         */
        get: operations["getWorldMetadata"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/worlds/{worldId}/publish": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
            };
            cookie?: never;
        };
        /**
         * Get World Publish Status
         * @description Returns a worlds publish status.
         */
        get: operations["getWorldPublishStatus"];
        /**
         * Publish World
         * @description Publish a world. You can only publish one world per week.
         */
        put: operations["publishWorld"];
        post?: never;
        /**
         * Unpublish World
         * @description Unpublish a world.
         */
        delete: operations["unpublishWorld"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/worlds/{worldId}/{instanceId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
                /** @description Must be a valid instance ID. */
                instanceId: components["parameters"]["instanceId"];
            };
            cookie?: never;
        };
        /**
         * Get World Instance
         * @description Returns a worlds instance.
         */
        get: operations["getWorldInstance"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * UserExists
         * @description Status object representing if a queried user by username or userId exists or not. This model is primarily used by the `/auth/exists` endpoint, which in turn is used during registration. Please see the documentation on that endpoint for more information on usage.
         */
        UserExists: {
            /**
             * @description Status if a user exist with that username or userId.
             * @default false
             */
            userExists: boolean;
            /**
             * @description Is the username valid?
             * @default false
             */
            nameOk: boolean;
        };
        /** Response */
        Response: {
            message?: string;
            status_code: number;
        };
        /** Error */
        Error: {
            error?: components["schemas"]["Response"];
        };
        /** AccountDeletionLog */
        AccountDeletionLog: {
            /**
             * @description Typically "Deletion requested" or "Deletion canceled". Other messages like "Deletion completed" may exist, but are these are not possible to see as a regular user.
             * @default Deletion requested
             * @example Deletion requested
             */
            message: string;
            /**
             * Format: date-time
             * @description When the deletion is scheduled to happen, standard is 14 days after the request.
             */
            deletionScheduled?: string | null;
            /**
             * Format: date-time
             * @description Date and time of the deletion request.
             */
            dateTime?: string;
        };
        /**
         * UserID
         * @description A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
         * @example usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469
         */
        UserID: string;
        /**
         * BadgeID
         * @example bdg_a60e514a-8cb7-4702-8f24-2786992be1a8
         */
        BadgeID: string;
        /** Badge */
        Badge: {
            /**
             * Format: date-time
             * @description only present in CurrentUser badges
             */
            assignedAt?: string | null;
            badgeDescription: string;
            badgeId: components["schemas"]["BadgeID"];
            /** @description direct url to image */
            badgeImageUrl: string;
            badgeName: string;
            /** @description only present in CurrentUser badges */
            hidden?: boolean | null;
            showcased: boolean;
            /**
             * Format: date-time
             * @description only present in CurrentUser badges
             */
            updatedAt?: string | null;
        };
        /**
         * AvatarID
         * @example avtr_912d66a4-4714-43b8-8407-7de2cafbf55b
         */
        AvatarID: string;
        /**
         * CurrentAvatarImageUrl
         * @description When profilePicOverride is not empty, use it instead.
         * @example https://vrchat.com/api/1/file/file_ae46d521-7281-4b38-b365-804b32a1d6a7/1/file
         */
        CurrentAvatarImageUrl: string;
        /**
         * CurrentAvatarThumbnailImageUrl
         * @description When profilePicOverride is not empty, use it instead.
         * @example https://vrchat.com/api/1/image/file_aae83ed9-d42d-4d72-9f4b-9f1e41ed17e1/1/256
         */
        CurrentAvatarThumbnailImageUrl: string;
        /**
         * Tag
         * @description Tags are a way to grant various access, assign restrictions or other kinds of metadata to various to objects such as worlds, users and avatars.
         *
         *     System tags starting with `system_` are granted automatically by the system, while admin tags with `admin_` are granted manually. More prefixes such as `language_ ` (to indicate that a player can speak the tagged language), and `author_tag_` (provided by a world author for search and sorting) exist as well.
         */
        Tag: string;
        /**
         * DeveloperType
         * @description "none" User is a normal user
         *     "trusted" Unknown
         *     "internal" Is a VRChat Developer
         *     "moderator" Is a VRChat Moderator
         *
         *     Staff can hide their developerType at will.
         * @default none
         * @enum {string}
         */
        DeveloperType: "none" | "trusted" | "internal" | "moderator";
        /**
         * WorldID
         * @description WorldID be "offline" on User profiles if you are not friends with that user.
         * @example wrld_ba913a96-fac4-4048-a062-9aa5db092812
         */
        WorldID: string;
        /**
         * Platform
         * @description This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
         * @example standalonewindows
         */
        Platform: string;
        /** PastDisplayName */
        PastDisplayName: {
            displayName: string;
            /** Format: date-time */
            updated_at: string;
        };
        /**
         * GroupID
         * @example grp_71a7ff59-112c-4e78-a990-c7cc650776e5
         */
        GroupID: string;
        /** CurrentUserPresence */
        CurrentUserPresence: {
            avatarThumbnail?: string | null;
            displayName?: string;
            groups?: components["schemas"]["GroupID"][] | null;
            id?: components["schemas"]["UserID"];
            instance?: string | null;
            /** @description either an InstanceType or an empty string */
            instanceType?: string | null;
            isRejoining?: string | null;
            /** @description either a Platform or an empty string */
            platform?: string | null;
            profilePicOverride?: string | null;
            /** @description either a UserStatus or empty string */
            status?: string | null;
            travelingToInstance?: string | null;
            travelingToWorld?: components["schemas"]["WorldID"];
            world?: components["schemas"]["WorldID"];
        };
        /**
         * UserState
         * @description * "online" User is online in VRChat
         *     * "active" User is online, but not in VRChat
         *     * "offline" User is offline
         *
         *     Always offline when returned through `getCurrentUser` (/auth/user).
         * @default offline
         * @enum {string}
         */
        UserState: "offline" | "active" | "online";
        /**
         * UserStatus
         * @description Defines the User's current status, for example "ask me", "join me" or "offline. This status is a combined indicator of their online activity and privacy preference.
         * @default offline
         * @enum {string}
         */
        UserStatus: "active" | "join me" | "ask me" | "busy" | "offline";
        /** CurrentUser */
        CurrentUser: {
            /** @example 7 */
            acceptedTOSVersion: number;
            /** @example 0 */
            acceptedPrivacyVersion?: number;
            /** Format: date */
            accountDeletionDate?: string | null;
            /** @description   */
            accountDeletionLog?: components["schemas"]["AccountDeletionLog"][] | null;
            /** @description   */
            activeFriends?: components["schemas"]["UserID"][];
            allowAvatarCopying: boolean;
            /** @description   */
            badges?: components["schemas"]["Badge"][];
            bio: string;
            /** @description   */
            bioLinks: string[];
            currentAvatar: components["schemas"]["AvatarID"];
            currentAvatarAssetUrl: string;
            currentAvatarImageUrl: components["schemas"]["CurrentAvatarImageUrl"];
            currentAvatarThumbnailImageUrl: components["schemas"]["CurrentAvatarThumbnailImageUrl"];
            currentAvatarTags: components["schemas"]["Tag"][];
            /** Format: date */
            date_joined: string;
            developerType: components["schemas"]["DeveloperType"];
            displayName: string;
            emailVerified: boolean;
            fallbackAvatar?: components["schemas"]["AvatarID"];
            /**
             * @deprecated
             * @description Always empty array.
             */
            friendGroupNames: string[];
            friendKey: string;
            friends: components["schemas"]["UserID"][];
            hasBirthday: boolean;
            hideContentFilterSettings?: boolean;
            userLanguage?: string | null;
            userLanguageCode?: string | null;
            hasEmail: boolean;
            hasLoggedInFromClient: boolean;
            hasPendingEmail: boolean;
            homeLocation: components["schemas"]["WorldID"];
            id: components["schemas"]["UserID"];
            /** @default true */
            isBoopingEnabled: boolean;
            /** @default false */
            isFriend: boolean;
            /** Format: date-time */
            last_activity?: string;
            /** Format: date-time */
            last_login: string;
            /** Format: date-time */
            last_mobile: string | null;
            last_platform: components["schemas"]["Platform"];
            obfuscatedEmail: string;
            obfuscatedPendingEmail: string;
            oculusId: string;
            googleId?: string;
            googleDetails?: Record<string, never>;
            picoId?: string;
            viveId?: string;
            offlineFriends?: components["schemas"]["UserID"][];
            onlineFriends?: components["schemas"]["UserID"][];
            /** @description   */
            pastDisplayNames: components["schemas"]["PastDisplayName"][];
            presence?: components["schemas"]["CurrentUserPresence"];
            profilePicOverride: string;
            profilePicOverrideThumbnail: string;
            pronouns: string;
            state: components["schemas"]["UserState"];
            status: components["schemas"]["UserStatus"];
            statusDescription: string;
            statusFirstTime: boolean;
            statusHistory: string[];
            steamDetails: Record<string, never>;
            steamId: string;
            tags: components["schemas"]["Tag"][];
            twoFactorAuthEnabled: boolean;
            /** Format: date-time */
            twoFactorAuthEnabledDate?: string | null;
            unsubscribe: boolean;
            /** Format: date-time */
            updated_at?: string;
            userIcon: string;
            /**
             * @deprecated
             * @description -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
             */
            username?: string;
        };
        /** TwoFactorAuthCode */
        TwoFactorAuthCode: {
            code: string;
        };
        /** Verify2FAResult */
        Verify2FAResult: {
            verified: boolean;
        };
        /** TwoFactorEmailCode */
        TwoFactorEmailCode: {
            code: string;
        };
        /** Verify2FAEmailCodeResult */
        Verify2FAEmailCodeResult: {
            verified: boolean;
        };
        /** VerifyAuthTokenResult */
        VerifyAuthTokenResult: {
            ok: boolean;
            token: string;
        };
        /** Success */
        Success: {
            success?: components["schemas"]["Response"];
        };
        /**
         * ReleaseStatus
         * @default public
         * @example public
         * @enum {string}
         */
        ReleaseStatus: "public" | "private" | "hidden" | "all";
        /**
         * UnityPackageID
         * @example unp_52b12c39-4163-457d-a4a9-630e7aff1bff
         */
        UnityPackageID: string;
        /**
         * UnityPackage
         * @example {
         *       "assetUrl": "https://vrchat.com/api/1/file/file_cd0caa7b-69ba-4715-8dfe-7d667a9d2537/65/file",
         *       "assetUrlObject": {},
         *       "assetVersion": 4,
         *       "created_at": "2020-09-10T06:13:27.777Z",
         *       "id": "unp_52b12c39-4163-457d-a4a9-630e7aff1bff",
         *       "platform": "standalonewindows",
         *       "pluginUrl": "",
         *       "pluginUrlObject": {},
         *       "unitySortNumber": 20180414000,
         *       "unityVersion": "2022.3.6f1"
         *     }
         */
        UnityPackage: {
            id: components["schemas"]["UnityPackageID"];
            assetUrl?: string | null;
            assetUrlObject?: Record<string, never>;
            assetVersion: number;
            /** Format: date-time */
            created_at?: string;
            platform: components["schemas"]["Platform"];
            pluginUrl?: string;
            pluginUrlObject?: Record<string, never>;
            /** Format: int64 */
            unitySortNumber?: number;
            /**
             * @default 5.3.4p1
             * @example 2022.3.6f1
             */
            unityVersion: string;
            impostorUrl?: string | null;
            scanStatus?: string;
            variant?: string;
        };
        /** Avatar */
        Avatar: {
            /** @description Not present from general serach `/avatars`, only on specific requests `/avatars/{avatarId}`. */
            assetUrl?: string;
            /** @description Not present from general serach `/avatars`, only on specific requests `/avatars/{avatarId}`.
             *     **Deprecation:** `Object` has unknown usage/fields, and is always empty. Use normal `Url` field instead. */
            assetUrlObject?: Record<string, never>;
            authorId: components["schemas"]["UserID"];
            authorName: string;
            /** Format: date-time */
            created_at: string;
            description: string;
            /** @default false */
            featured: boolean;
            id: components["schemas"]["AvatarID"];
            imageUrl: string;
            name: string;
            releaseStatus: components["schemas"]["ReleaseStatus"];
            /** @description   */
            tags: components["schemas"]["Tag"][];
            thumbnailImageUrl: string;
            unityPackageUrl: string;
            /**
             * @deprecated
             * @description **Deprecation:** `Object` has unknown usage/fields, and is always empty. Use normal `Url` field instead.
             */
            unityPackageUrlObject: {
                unityPackageUrl?: string;
            };
            unityPackages: components["schemas"]["UnityPackage"][];
            /** Format: date-time */
            updated_at: string;
            /**
             * @default 0
             * @example 68
             */
            version: number;
        };
        /**
         * SortOption
         * @default popularity
         * @example popularity
         * @enum {string}
         */
        SortOption: "popularity" | "heat" | "trust" | "shuffle" | "random" | "favorites" | "reportScore" | "reportCount" | "publicationDate" | "labsPublicationDate" | "created" | "_created_at" | "updated" | "_updated_at" | "order" | "relevance" | "magic" | "name";
        /**
         * OrderOption
         * @default descending
         * @example descending
         * @enum {string}
         */
        OrderOption: "ascending" | "descending";
        /** CreateAvatarRequest */
        CreateAvatarRequest: {
            assetUrl?: string;
            id?: components["schemas"]["AvatarID"];
            name: string;
            description?: string;
            /** @description   */
            tags?: components["schemas"]["Tag"][];
            imageUrl: string;
            releaseStatus?: components["schemas"]["ReleaseStatus"];
            /** @default 1 */
            version: number;
            unityPackageUrl?: string;
            /**
             * @default 5.3.4p1
             * @example 2022.3.6f1
             */
            unityVersion: string;
        };
        /** UpdateAvatarRequest */
        UpdateAvatarRequest: {
            assetUrl?: string;
            id?: components["schemas"]["AvatarID"];
            name?: string;
            description?: string;
            /** @description   */
            tags?: components["schemas"]["Tag"][];
            imageUrl?: string;
            releaseStatus?: components["schemas"]["ReleaseStatus"];
            /** @default 1 */
            version: number;
            unityPackageUrl?: string;
            /**
             * @default 5.3.4p1
             * @example 2022.3.6f1
             */
            unityVersion: string;
        };
        /**
         * TransactionID
         * @example txn_e5c72948-e735-4880-8245-24b2a41198b0
         */
        TransactionID: string;
        /**
         * TransactionStatus
         * @default active
         * @enum {string}
         */
        TransactionStatus: "active" | "failed" | "expired" | "chargeback";
        /**
         * SubscriptionPeriod
         * @default month
         * @enum {string}
         */
        SubscriptionPeriod: "hour" | "day" | "week" | "month" | "year";
        /**
         * Subscription
         * @example {
         *       "id": "vrchatplus-yearly",
         *       "steamItemId": "5000",
         *       "amount": 9999,
         *       "description": "VRChat Plus (Yearly)",
         *       "period": "year",
         *       "tier": 5
         *     }
         */
        Subscription: {
            id: string;
            steamItemId: string;
            oculusSku?: string;
            googleProductId?: string;
            googlePlanId?: string;
            picoSku?: string;
            amount: number;
            description: string;
            period: components["schemas"]["SubscriptionPeriod"];
            tier: number;
        };
        /**
         * TransactionSteamWalletInfo
         * @example {
         *       "state": "",
         *       "country": "SE",
         *       "currency": "EUR",
         *       "status": "Trusted"
         *     }
         */
        TransactionSteamWalletInfo: {
            state: string;
            /**
             * @default US
             * @example SE
             */
            country: string;
            /**
             * @default USD
             * @example EUR
             */
            currency: string;
            /** @example Trusted */
            status: string;
        };
        /** TransactionSteamInfo */
        TransactionSteamInfo: {
            walletInfo: components["schemas"]["TransactionSteamWalletInfo"];
            /** @description Steam User ID */
            steamId: string;
            /** @description Steam Order ID */
            orderId: string;
            /** @description Empty */
            steamUrl: string;
            /** @description Steam Transaction ID, NOT the same as VRChat TransactionID */
            transId: string;
        };
        /**
         * TransactionAgreement
         * @description Represents a single Transaction, which is likely between VRChat and Steam.
         */
        TransactionAgreement: {
            agreementId: string;
            itemId: number;
            agreement: string;
            /** @description This is NOT TransactionStatus, but whatever Steam return. */
            status: string;
            period: string;
            frequency: number;
            billingType: string;
            startDate: string;
            endDate: string;
            recurringAmt: number;
            currency: string;
            timeCreated: string;
            nextPayment: string;
            lastPayment: string;
            lastAmount: number;
            lastAmountVat: number;
            outstanding: number;
            failedAttempts: number;
        };
        /** Transaction */
        Transaction: {
            id: components["schemas"]["TransactionID"];
            userId?: components["schemas"]["UserID"];
            userDisplayName?: string;
            status: components["schemas"]["TransactionStatus"];
            subscription: components["schemas"]["Subscription"];
            /** @default false */
            sandbox: boolean;
            /** Format: date-time */
            created_at: string;
            /** Format: date-time */
            updated_at: string;
            steam?: components["schemas"]["TransactionSteamInfo"];
            agreement?: components["schemas"]["TransactionAgreement"];
            error: string;
            /** @default false */
            isGift: boolean;
            /** @default false */
            isTokens: boolean;
        };
        /**
         * LicenseGroupID
         * @example lgrp_608513da-b213-4e15-80af-bd88c27f0979
         */
        LicenseGroupID: string;
        /** UserSubscription */
        UserSubscription: {
            /** @example vrchatplus-yearly */
            id: string;
            transactionId: components["schemas"]["TransactionID"];
            /**
             * @description Which "Store" it came from. Right now only Stores are "Steam" and "Admin".
             * @example Steam
             */
            store: string;
            /** @example 5000 */
            steamItemId?: string;
            /** @example 9999 */
            amount: number;
            /** @example VRChat Plus (Yearly) */
            description: string;
            period: components["schemas"]["SubscriptionPeriod"];
            /** @example 5 */
            tier: number;
            /** @default true */
            active: boolean;
            status: components["schemas"]["TransactionStatus"];
            starts?: string;
            /** Format: date-time */
            expires: string;
            /** Format: date-time */
            created_at: string;
            /** Format: date-time */
            updated_at: string;
            licenseGroups: components["schemas"]["LicenseGroupID"][];
            /** @default false */
            isGift: boolean;
        };
        /**
         * LicenseType
         * @default permission
         * @example permission
         * @enum {string}
         */
        LicenseType: "avatar" | "licenseGroup" | "permission" | "product";
        /**
         * LicenseAction
         * @default have
         * @example have
         * @enum {string}
         */
        LicenseAction: "wear" | "have";
        /** License */
        License: {
            /** @description Either a AvatarID, LicenseGroupID, PermissionID or ProductID. This depends on the `forType` field. */
            forId: string;
            forType: components["schemas"]["LicenseType"];
            forName: string;
            forAction: components["schemas"]["LicenseAction"];
        };
        /**
         * LicenseGroup
         * @example {
         *       "id": "lgrp_608513da-b213-4e15-80af-bd88c27f0979",
         *       "name": "vrcplus",
         *       "description": "VRC+ benefits",
         *       "licenses": [
         *         {
         *           "forId": "prms_1d9549db-d30a-48f3-a6b8-6741ce5a4283",
         *           "forType": "permission",
         *           "forName": "permission-user-icons",
         *           "forAction": "have"
         *         },
         *         {
         *           "forId": "prms_76f33deb-dd5d-46b7-b79d-e1f8f0a9a1e0",
         *           "forType": "permission",
         *           "forName": "permission-supporter-tags",
         *           "forAction": "have"
         *         },
         *         {
         *           "forId": "prms_0d9549db-d30a-48f3-a6b8-6741ce5a4283",
         *           "forType": "permission",
         *           "forName": "permission-invite-photos",
         *           "forAction": "have"
         *         },
         *         {
         *           "forId": "prms_dc02c512-4c03-479c-8c6a-d9329c023baf",
         *           "forType": "permission",
         *           "forName": "permission-user-gallery",
         *           "forAction": "have"
         *         },
         *         {
         *           "forId": "prms_153ac0b7-c2dd-43f9-96e3-c61fd2e85509",
         *           "forType": "permission",
         *           "forName": "permission-profile-pic-override",
         *           "forAction": "have"
         *         }
         *       ]
         *     }
         */
        LicenseGroup: {
            id: components["schemas"]["LicenseGroupID"];
            name: string;
            description: string;
            licenses: components["schemas"]["License"][];
        };
        /**
         * FavoriteID
         * @example fvrt_9568d189-8776-44a5-a8c8-defc981e44de
         */
        FavoriteID: string;
        /**
         * FavoriteType
         * @default friend
         * @enum {string}
         */
        FavoriteType: "world" | "friend" | "avatar";
        /** Favorite */
        Favorite: {
            /** @description MUST be either AvatarID, UserID or WorldID. */
            favoriteId: string;
            id: components["schemas"]["FavoriteID"];
            /** @description   */
            tags: components["schemas"]["Tag"][];
            type: components["schemas"]["FavoriteType"];
        };
        /** AddFavoriteRequest */
        AddFavoriteRequest: {
            type: components["schemas"]["FavoriteType"];
            /** @description Must be either AvatarID, WorldID or UserID. */
            favoriteId: string;
            /** @description Tags indicate which group this favorite belongs to. Adding multiple groups makes it show up in all. Removing it from one in that case removes it from all. */
            tags: components["schemas"]["Tag"][];
        };
        /**
         * FavoriteGroupID
         * @example fvgrp_8a02a44b-dc3a-4a9a-bc77-77fa37996fc7
         */
        FavoriteGroupID: string;
        /**
         * FavoriteGroupVisibility
         * @default private
         * @example private
         * @enum {string}
         */
        FavoriteGroupVisibility: "private" | "friends" | "public";
        /** FavoriteGroup */
        FavoriteGroup: {
            displayName: string;
            id: components["schemas"]["FavoriteGroupID"];
            name: string;
            ownerDisplayName: string;
            ownerId: components["schemas"]["UserID"];
            /** @description   */
            tags: components["schemas"]["Tag"][];
            type: components["schemas"]["FavoriteType"];
            visibility: components["schemas"]["FavoriteGroupVisibility"];
        };
        /** UpdateFavoriteGroupRequest */
        UpdateFavoriteGroupRequest: {
            displayName?: string;
            visibility?: components["schemas"]["FavoriteGroupVisibility"];
            /** @description Tags on FavoriteGroups are believed to do nothing. */
            tags?: components["schemas"]["Tag"][];
        };
        /**
         * FileID
         * @example file_ce35d830-e20a-4df0-a6d4-5aaef4508044
         */
        FileID: string;
        /**
         * MIMEType
         * @default image/jpeg
         * @example image/jpeg
         * @enum {string}
         */
        MIMEType: "image/jpeg" | "image/jpg" | "image/png" | "image/webp" | "image/gif" | "image/bmp" | "image/svg＋xml" | "image/tiff" | "application/x-avatar" | "application/x-world" | "application/gzip" | "application/x-rsync-signature" | "application/x-rsync-delta" | "application/octet-stream";
        /**
         * FileStatus
         * @default waiting
         * @example complete
         * @enum {string}
         */
        FileStatus: "waiting" | "complete" | "none" | "queued";
        /** FileData */
        FileData: {
            /**
             * @default queued
             * @enum {string}
             */
            category: "multipart" | "queued" | "simple";
            fileName: string;
            md5?: string;
            sizeInBytes: number;
            status: components["schemas"]["FileStatus"];
            /** @default  */
            uploadId: string;
            url: string;
        };
        /** FileVersion */
        FileVersion: {
            /** Format: date-time */
            created_at: string;
            /**
             * @description Usually only present if `true`
             * @default true
             */
            deleted: boolean;
            delta?: components["schemas"]["FileData"];
            file?: components["schemas"]["FileData"];
            signature?: components["schemas"]["FileData"];
            status: components["schemas"]["FileStatus"];
            /**
             * @description Incremental version counter, can only be increased.
             * @default 0
             */
            version: number;
        };
        /** File */
        File: {
            /** @example .unitypackage */
            extension: string;
            id: components["schemas"]["FileID"];
            mimeType: components["schemas"]["MIMEType"];
            /** @example Example File */
            name: string;
            ownerId: components["schemas"]["UserID"];
            /** @description   */
            tags: components["schemas"]["Tag"][];
            /** @description   */
            versions: components["schemas"]["FileVersion"][];
        };
        /** CreateFileRequest */
        CreateFileRequest: {
            name: string;
            mimeType: components["schemas"]["MIMEType"];
            extension: string;
            /** @description   */
            tags?: components["schemas"]["Tag"][];
        };
        /** CreateFileVersionRequest */
        CreateFileVersionRequest: {
            signatureMd5: string;
            signatureSizeInBytes: number;
            fileMd5?: string;
            fileSizeInBytes?: number;
        };
        /** FinishFileDataUploadRequest */
        FinishFileDataUploadRequest: {
            /** @description Array of ETags uploaded. */
            etags?: string[];
            /**
             * @deprecated
             * @description Always a zero in string form, despite how many parts uploaded.
             * @default 0
             * @example 0
             */
            nextPartNumber: string;
            /**
             * @deprecated
             * @description Always a zero in string form, despite how many parts uploaded.
             * @default 0
             * @example 0
             */
            maxParts: string;
        };
        /** FileUploadURL */
        FileUploadURL: {
            url: string;
        };
        /** FileVersionUploadStatus */
        FileVersionUploadStatus: {
            /** @example xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx_xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxx_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx..xxxxxxxxxxxxxxxxxxxxxxx */
            uploadId: string;
            /** @example Avatar-MyAvatar-Un.file_00000000-0000-0000-0000-000000000000.1.unitypackage */
            fileName: string;
            /** @example 0 */
            nextPartNumber: number;
            /** @example 1000 */
            maxParts: number;
            parts: Record<string, never>[];
            /** @description Unknown */
            etags: Record<string, never>[];
        };
        /** LimitedUser */
        LimitedUser: {
            bio?: string;
            /** @description   */
            bioLinks?: string[];
            currentAvatarImageUrl?: components["schemas"]["CurrentAvatarImageUrl"];
            currentAvatarThumbnailImageUrl?: components["schemas"]["CurrentAvatarThumbnailImageUrl"];
            currentAvatarTags?: components["schemas"]["Tag"][];
            developerType: components["schemas"]["DeveloperType"];
            displayName: string;
            fallbackAvatar?: components["schemas"]["AvatarID"];
            id: components["schemas"]["UserID"];
            isFriend: boolean;
            last_platform: components["schemas"]["Platform"];
            profilePicOverride?: string;
            pronouns?: string;
            status: components["schemas"]["UserStatus"];
            statusDescription: string;
            /** @description <- Always empty. */
            tags: components["schemas"]["Tag"][];
            userIcon?: string;
            /**
             * @deprecated
             * @description -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
             */
            username?: string;
            location?: string;
            friendKey?: string;
        };
        /**
         * NotificationType
         * @default friendRequest
         * @enum {string}
         */
        NotificationType: "friendRequest" | "invite" | "inviteResponse" | "message" | "requestInvite" | "requestInviteResponse" | "votetokick";
        /** Notification */
        Notification: {
            /** Format: date-time */
            created_at: string;
            /**
             * @description **NOTICE:** This is not a JSON object when received from the REST API, but it is when received from the Websocket API. When received from the REST API, this is a json **encoded** object, meaning you have to json-de-encode to get the NotificationDetail object depending on the NotificationType.
             * @default {}
             * @example OneOf: {}, NotificationDetailInvite, NotificationDetailInviteResponse, NotificationDetailRequestInvite, NotificationDetailRequestInviteResponse, NotificationDetailVoteToKick
             */
            details: string;
            id: string;
            /** @example This is a generated invite to VRChat Hub */
            message: string;
            /**
             * @description Not included in notification objects received from the Websocket API
             * @default false
             */
            seen: boolean;
            /** @description Not included in notification objects received from the REST API */
            receiverUserId?: components["schemas"]["UserID"];
            senderUserId: components["schemas"]["UserID"];
            /**
             * @deprecated
             * @description -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
             */
            senderUsername?: string;
            type: components["schemas"]["NotificationType"];
        };
        /** FriendStatus */
        FriendStatus: {
            /** @default false */
            incomingRequest: boolean;
            /** @default false */
            isFriend: boolean;
            /** @default false */
            outgoingRequest: boolean;
        };
        /**
         * GroupShortCode
         * @example ABC123
         */
        GroupShortCode: string;
        /**
         * GroupDiscriminator
         * @example 1234
         */
        GroupDiscriminator: string;
        /**
         * @default inactive
         * @example member
         * @enum {string}
         */
        GroupMemberStatus: "inactive" | "member" | "requested" | "invited" | "banned" | "userblocked";
        /**
         * GroupGalleryID
         * @example ggal_a03a4b55-4ca6-4490-9519-40ba6351a233
         */
        GroupGalleryID: string;
        /**
         * GroupRoleID
         * @example grol_459d3911-f672-44bc-b84d-e54ffe7960fe
         */
        GroupRoleID: string;
        /** GroupMember */
        GroupGallery: {
            id?: components["schemas"]["GroupGalleryID"];
            /**
             * @description Name of the gallery.
             * @example Example Gallery
             */
            name?: string;
            /**
             * @description Description of the gallery.
             * @example Example Description
             */
            description?: string;
            /**
             * @description Whether the gallery is members only.
             * @default false
             * @example false
             */
            membersOnly: boolean;
            /** @description   */
            roleIdsToView?: components["schemas"]["GroupRoleID"][] | null;
            /** @description   */
            roleIdsToSubmit?: components["schemas"]["GroupRoleID"][] | null;
            /** @description   */
            roleIdsToAutoApprove?: components["schemas"]["GroupRoleID"][] | null;
            /** @description   */
            roleIdsToManage?: components["schemas"]["GroupRoleID"][] | null;
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            updatedAt?: string;
        };
        /** LimitedGroup */
        LimitedGroup: {
            id?: components["schemas"]["GroupID"];
            name?: string;
            shortCode?: components["schemas"]["GroupShortCode"];
            discriminator?: components["schemas"]["GroupDiscriminator"];
            description?: string;
            iconUrl?: string | null;
            bannerUrl?: string | null;
            ownerId?: components["schemas"]["UserID"];
            rules?: string | null;
            iconId?: string | null;
            bannerId?: string | null;
            memberCount?: number;
            /** @description   */
            tags?: components["schemas"]["Tag"][];
            /** Format: date-time */
            createdAt?: string;
            membershipStatus?: components["schemas"]["GroupMemberStatus"];
            isSearchable?: boolean;
            /** @description   */
            galleries?: components["schemas"]["GroupGallery"][];
        };
        /**
         * GroupJoinState
         * @default open
         * @enum {string}
         */
        GroupJoinState: "closed" | "invite" | "request" | "open";
        /**
         * GroupPrivacy
         * @default default
         * @enum {string}
         */
        GroupPrivacy: "default" | "private";
        /**
         * GroupRoleTemplate
         * @default default
         * @enum {string}
         */
        GroupRoleTemplate: "default" | "managedFree" | "managedInvite" | "managedRequest";
        /** CreateGroupRequest */
        CreateGroupRequest: {
            name: string;
            shortCode: string;
            description?: string;
            joinState?: components["schemas"]["GroupJoinState"];
            /** @default null */
            iconId: string | null;
            /** @default null */
            bannerId: string | null;
            privacy?: components["schemas"]["GroupPrivacy"];
            roleTemplate: components["schemas"]["GroupRoleTemplate"];
        };
        /**
         * GroupMemberID
         * @example gmem_95cdb3b4-4643-4eb6-bdab-46a4e1e5ce37
         */
        GroupMemberID: string;
        /** GroupMyMember */
        GroupMyMember: {
            id?: components["schemas"]["GroupMemberID"];
            groupId?: components["schemas"]["GroupID"];
            userId?: components["schemas"]["UserID"];
            roleIds?: components["schemas"]["GroupRoleID"][];
            acceptedByDisplayName?: string | null;
            acceptedById?: components["schemas"]["UserID"];
            /** Format: date-time */
            createdAt?: string;
            managerNotes?: string;
            /** @example member */
            membershipStatus?: string;
            /** @default true */
            isSubscribedToAnnouncements: boolean;
            /** @example visible */
            visibility?: string;
            /** @default false */
            isRepresenting: boolean;
            /** Format: date-time */
            joinedAt?: string;
            bannedAt?: string | null;
            /** @default false */
            has2FA: boolean;
            /** @default false */
            hasJoinedFromPurchase: boolean;
            /** Format: date-time */
            lastPostReadAt?: string | null;
            mRoleIds?: string[];
            permissions?: string[];
        };
        /** GroupRole */
        GroupRole: {
            id?: components["schemas"]["GroupRoleID"];
            groupId?: components["schemas"]["GroupID"];
            name?: string;
            description?: string;
            /** @default false */
            isSelfAssignable: boolean;
            permissions?: string[];
            /** @default false */
            isManagementRole: boolean;
            /** @default false */
            requiresTwoFactor: boolean;
            /** @default false */
            requiresPurchase: boolean;
            order?: number;
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            updatedAt?: string;
        };
        /** Group */
        Group: {
            id?: components["schemas"]["GroupID"];
            name?: string;
            shortCode?: components["schemas"]["GroupShortCode"];
            discriminator?: components["schemas"]["GroupDiscriminator"];
            description?: string;
            iconUrl?: string | null;
            bannerUrl?: string | null;
            privacy?: components["schemas"]["GroupPrivacy"];
            ownerId?: components["schemas"]["UserID"];
            rules?: string | null;
            links?: string[];
            languages?: string[];
            iconId?: string | null;
            bannerId?: string | null;
            memberCount?: number;
            /** Format: date-time */
            memberCountSyncedAt?: string;
            /** @default false */
            isVerified: boolean;
            joinState?: components["schemas"]["GroupJoinState"];
            tags?: components["schemas"]["Tag"][];
            transferTargetId?: components["schemas"]["UserID"];
            galleries?: components["schemas"]["GroupGallery"][];
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            updatedAt?: string;
            /** Format: date-time */
            lastPostCreatedAt?: string | null;
            onlineMemberCount?: number;
            membershipStatus?: components["schemas"]["GroupMemberStatus"];
            myMember?: components["schemas"]["GroupMyMember"];
            /** @description Only returned if ?includeRoles=true is specified. */
            roles?: components["schemas"]["GroupRole"][] | null;
        };
        /** UpdateGroupRequest */
        UpdateGroupRequest: {
            name?: string;
            shortCode?: string;
            description?: string;
            joinState?: components["schemas"]["GroupJoinState"];
            /** @default null */
            iconId: string | null;
            /** @default null */
            bannerId: string | null;
            /** @description 3 letter language code */
            languages?: string[];
            links?: string[];
            rules?: string;
            /** @description   */
            tags?: components["schemas"]["Tag"][];
        };
        /**
         * GroupAnnouncementID
         * @example gpos_71a7ff59-112c-4e78-a990-c7cc650776e5
         */
        GroupAnnouncementID: string;
        /** GroupAnnouncement */
        GroupAnnouncement: {
            id?: components["schemas"]["GroupAnnouncementID"];
            groupId?: components["schemas"]["GroupID"];
            authorId?: components["schemas"]["UserID"];
            title?: string | null;
            text?: string | null;
            imageId?: components["schemas"]["FileID"];
            imageUrl?: string | null;
            /** Format: date-time */
            createdAt?: string | null;
            /** Format: date-time */
            updatedAt?: string | null;
        };
        /** CreateGroupAnnouncementRequest */
        CreateGroupAnnouncementRequest: {
            /**
             * @description Announcement title
             * @example Event is starting soon!
             */
            title: string;
            /**
             * @description Announcement text
             * @example Come join us for the event!
             */
            text?: string;
            imageId?: components["schemas"]["FileID"];
            /**
             * @description Send notification to group members.
             * @default false
             * @example false
             */
            sendNotification: boolean;
        };
        /**
         * GroupAuditLogID
         * @example gaud_71a7ff59-112c-4e78-a990-c7cc650776e5
         */
        GroupAuditLogID: string;
        /** GroupAuditLogEntry */
        GroupAuditLogEntry: {
            id?: components["schemas"]["GroupAuditLogID"];
            /** Format: date-time */
            created_at?: string;
            groupId?: components["schemas"]["GroupID"];
            actorId?: components["schemas"]["UserID"];
            actorDisplayName?: string;
            /** @description Typically GroupID or GroupRoleID, but could be other types of IDs. */
            targetId?: string;
            /**
             * @description The type of event that occurred. This is a string that is prefixed with the type of object that the event occurred on. For example, a group role update event would be prefixed with `group.role`.
             * @default group.update
             * @example group.role.update
             */
            eventType: string;
            /**
             * @description A human-readable description of the event.
             * @example Group role updated
             */
            description?: string;
            /**
             * @description The data associated with the event. The format of this data is dependent on the event type.
             * @example {
             *       "description": {
             *         "old": "My exciting new group.  It's pretty nifty!",
             *         "new": "My exciting new group. It's pretty nifty!"
             *       },
             *       "joinState": {
             *         "old": "closed",
             *         "new": "request"
             *       }
             *     }
             */
            data?: Record<string, never>;
        };
        /** PaginatedGroupAuditLogEntryList */
        PaginatedGroupAuditLogEntryList: {
            /** @description   */
            results?: components["schemas"]["GroupAuditLogEntry"][];
            /** @description The total number of results that the query would return if there were no pagination. */
            totalCount?: number;
            /** @description Whether there are more results after this page. */
            hasNext?: boolean;
        };
        /**
         * GroupMemberLimitedUser
         * @description Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
         */
        GroupMemberLimitedUser: {
            id?: components["schemas"]["UserID"];
            displayName?: string;
            thumbnailUrl?: string | null;
            iconUrl?: string;
            profilePicOverride?: string;
            currentAvatarThumbnailImageUrl?: string | null;
            currentAvatarTags?: components["schemas"]["Tag"][];
        };
        /** GroupMember */
        GroupMember: {
            id?: components["schemas"]["GroupMemberID"];
            groupId?: components["schemas"]["GroupID"];
            userId?: components["schemas"]["UserID"];
            /**
             * @description Whether the user is representing the group. This makes the group show up above the name tag in-game.
             * @default false
             * @example true
             */
            isRepresenting: boolean;
            user?: components["schemas"]["GroupMemberLimitedUser"];
            roleIds?: components["schemas"]["GroupRoleID"][];
            mRoleIds?: components["schemas"]["GroupRoleID"][];
            /** Format: date-time */
            joinedAt?: string | null;
            membershipStatus?: components["schemas"]["GroupMemberStatus"];
            /** @example visible */
            visibility?: string;
            /** @default false */
            isSubscribedToAnnouncements: boolean;
            /**
             * Format: date-time
             * @description Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
             */
            createdAt?: string | null;
            /**
             * Format: date-time
             * @description Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
             */
            bannedAt?: string | null;
            /** @description Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user. */
            managerNotes?: string | null;
            /** Format: date-time */
            lastPostReadAt?: string | null;
            hasJoinedFromPurchase?: boolean;
        };
        /** BanGroupMemberRequest */
        BanGroupMemberRequest: {
            userId: components["schemas"]["UserID"];
        };
        /** CreateGroupGalleryRequest */
        CreateGroupGalleryRequest: {
            /**
             * @description Name of the gallery.
             * @example Example Gallery
             */
            name: string;
            /**
             * @description Description of the gallery.
             * @example Example Description
             */
            description?: string;
            /**
             * @description Whether the gallery is members only.
             * @default false
             * @example false
             */
            membersOnly: boolean;
            /** @description   */
            roleIdsToView?: components["schemas"]["GroupRoleID"][] | null;
            /** @description   */
            roleIdsToSubmit?: components["schemas"]["GroupRoleID"][] | null;
            /** @description   */
            roleIdsToAutoApprove?: components["schemas"]["GroupRoleID"][] | null;
            /** @description   */
            roleIdsToManage?: components["schemas"]["GroupRoleID"][] | null;
        };
        /**
         * GroupGalleryImageID
         * @example ggim_71a7ff59-112c-4e78-a990-c7cc650776e5
         */
        GroupGalleryImageID: string;
        /** GroupGalleryImage */
        GroupGalleryImage: {
            id?: components["schemas"]["GroupGalleryImageID"];
            groupId?: components["schemas"]["GroupID"];
            galleryId?: components["schemas"]["GroupGalleryID"];
            fileId?: components["schemas"]["FileID"];
            /**
             * Format: uri
             * @example https://vrchat.com/api/1/file/file_ce35d830-e20a-4df0-a6d4-5aaef4508044/1/file
             */
            imageUrl?: string;
            /** Format: date-time */
            createdAt?: string;
            submittedByUserId?: components["schemas"]["UserID"];
            /**
             * @default false
             * @example true
             */
            approved: boolean;
            approvedByUserId?: components["schemas"]["UserID"];
            /** Format: date-time */
            approvedAt?: string;
        };
        /** UpdateGroupGalleryRequest */
        UpdateGroupGalleryRequest: {
            /**
             * @description Name of the gallery.
             * @example Example Gallery
             */
            name?: string;
            /**
             * @description Description of the gallery.
             * @example Example Description
             */
            description?: string;
            /**
             * @description Whether the gallery is members only.
             * @default false
             * @example false
             */
            membersOnly: boolean;
            /** @description   */
            roleIdsToView?: components["schemas"]["GroupRoleID"][] | null;
            /** @description   */
            roleIdsToSubmit?: components["schemas"]["GroupRoleID"][] | null;
            /** @description   */
            roleIdsToAutoApprove?: components["schemas"]["GroupRoleID"][] | null;
            /** @description   */
            roleIdsToManage?: components["schemas"]["GroupRoleID"][] | null;
        };
        /** AddGroupGalleryImageRequest */
        AddGroupGalleryImageRequest: {
            fileId: components["schemas"]["FileID"];
        };
        /**
         * InstanceID
         * @description InstanceID can be "offline" on User profiles if you are not friends with that user and "private" if you are friends and user is in private instance.
         * @example 12345~hidden(usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469)~region(eu)~nonce(27e8414a-59a0-4f3d-af1f-f27557eb49a2)
         */
        InstanceID: string;
        /**
         * UdonProductId
         * @description A unique ID of a Udon Product
         * @example prod_c1644b5b-3ca4-45b4-97c6-a2a0de70d469
         */
        UdonProductId: string;
        /** World */
        World: {
            authorId: components["schemas"]["UserID"];
            authorName: string;
            /** @example 8 */
            capacity: number;
            /** @example 4 */
            recommendedCapacity: number;
            /** Format: date-time */
            created_at: string;
            description: string;
            /**
             * @default 0
             * @example 12024
             */
            favorites: number;
            /** @default false */
            featured: boolean;
            /**
             * @default 0
             * @example 5
             */
            heat: number;
            id: components["schemas"]["WorldID"];
            imageUrl: string;
            /** @description Will always be an empty list when unauthenticated. */
            instances?: unknown[][];
            /** @example none */
            labsPublicationDate: string;
            name: string;
            namespace?: string;
            /**
             * @description Will always be `0` when unauthenticated.
             * @default 0
             * @example 47
             */
            occupants: number;
            /** @default vrchat */
            organization: string;
            /**
             * @default 0
             * @example 8
             */
            popularity: number;
            previewYoutubeId?: string | null;
            /**
             * @description Will always be `0` when unauthenticated.
             * @default 0
             * @example 1
             */
            privateOccupants: number;
            /**
             * @description Will always be `0` when unauthenticated.
             * @default 0
             * @example 46
             */
            publicOccupants: number;
            /** @example none */
            publicationDate: string;
            releaseStatus: components["schemas"]["ReleaseStatus"];
            /** @description   */
            tags: components["schemas"]["Tag"][];
            thumbnailImageUrl: string;
            /** @description Empty if unauthenticated. */
            unityPackages?: components["schemas"]["UnityPackage"][];
            /** Format: date-time */
            updated_at: string;
            /**
             * @default 0
             * @example 68
             */
            version: number;
            /**
             * @default 0
             * @example 9988675
             */
            visits: number;
            udonProducts?: components["schemas"]["UdonProductId"][];
        };
        /** GroupInstance */
        GroupInstance: {
            /** @example 12345~hidden(usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469)~region(eu)~nonce(27e8414a-59a0-4f3d-af1f-f27557eb49a2) */
            instanceId: string;
            location: components["schemas"]["InstanceID"];
            world: components["schemas"]["World"];
            /** @example 6 */
            memberCount: number;
        };
        /** CreateGroupInviteRequest */
        CreateGroupInviteRequest: {
            userId: components["schemas"]["UserID"];
            /** @default true */
            confirmOverrideBlock: boolean;
        };
        /**
         * GroupSearchSort
         * @example joinedAt:asc
         * @enum {string}
         */
        GroupSearchSort: "joinedAt:asc" | "joinedAt:desc";
        /** GroupLimitedMember */
        GroupLimitedMember: {
            id?: components["schemas"]["GroupMemberID"];
            groupId?: components["schemas"]["GroupID"];
            userId?: components["schemas"]["UserID"];
            /**
             * @description Whether the user is representing the group. This makes the group show up above the name tag in-game.
             * @default false
             * @example true
             */
            isRepresenting: boolean;
            roleIds?: components["schemas"]["GroupRoleID"][];
            mRoleIds?: components["schemas"]["GroupRoleID"][];
            /** Format: date-time */
            joinedAt?: string | null;
            membershipStatus?: components["schemas"]["GroupMemberStatus"];
            /** @example visible */
            visibility?: string;
            /** @default false */
            isSubscribedToAnnouncements: boolean;
            /**
             * Format: date-time
             * @description Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
             */
            createdAt?: string | null;
            /**
             * Format: date-time
             * @description Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
             */
            bannedAt?: string | null;
            /** @description Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user. */
            managerNotes?: string | null;
            /** Format: date-time */
            lastPostReadAt?: string | null;
            hasJoinedFromPurchase?: boolean;
        };
        /**
         * GroupUserVisibility
         * @example visible
         * @enum {string}
         */
        GroupUserVisibility: "visible" | "hidden" | "friends";
        /** UpdateGroupMemberRequest */
        UpdateGroupMemberRequest: {
            visibility?: components["schemas"]["GroupUserVisibility"];
            isSubscribedToAnnouncements?: boolean;
            managerNotes?: string;
        };
        /**
         * GroupRoleIDList
         * @description
         */
        GroupRoleIDList: components["schemas"]["GroupRoleID"][];
        /**
         * GroupPermission
         * @description A permission that can be granted to a role in a group.
         */
        GroupPermission: {
            /**
             * @description The name of the permission.
             * @example group-data-manage
             */
            name?: string;
            /**
             * @description The display name of the permission.
             * @example Manage Group Data
             */
            displayName?: string;
            /**
             * @description Human-readable description of the permission.
             * @example Allows role to edit group details (name, description, joinState, initialRoles, etc).
             */
            help?: string;
            /**
             * @description Whether this permission is a "management" permission.
             * @default false
             * @example true
             */
            isManagementPermission: boolean;
            /**
             * @description Whether the user is allowed to add this permission to a role.
             * @default false
             * @example true
             */
            allowedToAdd: boolean;
        };
        /**
         * NotificationID
         * @example not_00000000-0000-0000-0000-000000000000
         */
        NotificationID: string;
        /**
         * GroupPostVisibility
         * @example public
         * @enum {string}
         */
        GroupPostVisibility: "group" | "public";
        /** GroupPost */
        GroupPost: {
            id?: components["schemas"]["NotificationID"];
            groupId?: components["schemas"]["GroupID"];
            authorId?: components["schemas"]["UserID"];
            editorId?: components["schemas"]["UserID"];
            visibility?: components["schemas"]["GroupPostVisibility"];
            roleId?: components["schemas"]["GroupRoleIDList"];
            title?: string;
            text?: string;
            imageId?: components["schemas"]["FileID"];
            imageUrl?: string | null;
            /** Format: date-time */
            createdAt?: string;
            /** Format: date-time */
            updatedAt?: string;
        };
        /** CreateGroupPostRequest */
        CreateGroupPostRequest: {
            /**
             * @description Post title
             * @example Event is starting soon!
             */
            title: string;
            /**
             * @description Post text
             * @example Come join us for the event!
             */
            text: string;
            imageId?: components["schemas"]["FileID"];
            /**
             * @description Send notification to group members.
             * @default false
             * @example false
             */
            sendNotification: boolean;
            roleIds?: components["schemas"]["GroupRoleIDList"];
            visibility: components["schemas"]["GroupPostVisibility"];
        };
        /**
         * GroupJoinRequestAction
         * @example accept
         * @enum {string}
         */
        GroupJoinRequestAction: "accept" | "reject";
        /** RespondGroupJoinRequest */
        RespondGroupJoinRequest: {
            action: components["schemas"]["GroupJoinRequestAction"];
            /** @description Whether to block the user from requesting again */
            block?: boolean;
        };
        /** CreateGroupRequest */
        CreateGroupRoleRequest: {
            id?: string;
            name?: string;
            description?: string;
            /** @default false */
            isSelfAssignable: boolean;
            permissions?: string[];
        };
        /** UpdateGroupRoleRequest */
        UpdateGroupRoleRequest: {
            name?: string;
            description?: string;
            /** @default false */
            isSelfAssignable: boolean;
            permissions?: string[];
            order?: number;
        };
        /** InviteRequest */
        InviteRequest: {
            instanceId: components["schemas"]["InstanceID"];
            messageSlot?: number;
        };
        /** SentNotification */
        SentNotification: {
            /** Format: date-time */
            created_at: string;
            /** @example {
             *       "OneOf": [
             *         {},
             *         "NotificationDetailInvite",
             *         "NotificationDetailInviteResponse",
             *         "NotificationDetailRequestInvite",
             *         "NotificationDetailRequestInviteResponse",
             *         "NotificationDetailVoteToKick"
             *       ]
             *     } */
            details: Record<string, never>;
            id: string;
            /** @example This is a generated invite to VRChat Hub */
            message: string;
            receiverUserId: components["schemas"]["UserID"];
            senderUserId: components["schemas"]["UserID"];
            /**
             * @deprecated
             * @description -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
             */
            senderUsername?: string;
            type: components["schemas"]["NotificationType"];
        };
        /** RequestInviteRequest */
        RequestInviteRequest: {
            messageSlot?: number;
        };
        /** InviteResponse */
        InviteResponse: {
            responseSlot: number;
        };
        /**
         * InviteMessageType
         * @default message
         * @enum {string}
         */
        InviteMessageType: "message" | "response" | "request" | "requestResponse";
        /**
         * InviteMessageID
         * @example invm_24a1c14d-5e24-48e5-90e3-c3f712420ffa
         */
        InviteMessageID: string;
        /** InviteMessage */
        InviteMessage: {
            /** @default true */
            canBeUpdated: boolean;
            id: components["schemas"]["InviteMessageID"];
            message: string;
            messageType: components["schemas"]["InviteMessageType"];
            /**
             * @description Changes to 60 when updated, although probably server-side configurable.
             * @default 0
             */
            remainingCooldownMinutes: number;
            slot: number;
            /** Format: date-time */
            updatedAt: string;
        };
        /** UpdateInviteMessageRequest */
        UpdateInviteMessageRequest: {
            message: string;
        };
        /**
         * InstanceType
         * @example hidden
         * @enum {string}
         */
        InstanceType: "public" | "hidden" | "friends" | "private" | "group";
        /**
         * InstanceRegion
         * @description Instance region
         * @default us
         * @example us
         * @enum {string}
         */
        InstanceRegion: "us" | "use" | "eu" | "jp" | "unknown";
        /**
         * InstanceOwnerId
         * @description A groupId if the instance type is "group", null if instance type is public, or a userId otherwise
         * @example usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469
         */
        InstanceOwnerId: string | null;
        /**
         * GroupAccessType
         * @description Group access type when the instance type is "group"
         * @default members
         * @example members
         * @enum {string}
         */
        GroupAccessType: "public" | "plus" | "members";
        /** CreateInstanceRequest */
        CreateInstanceRequest: {
            worldId: components["schemas"]["WorldID"];
            type: components["schemas"]["InstanceType"];
            region: components["schemas"]["InstanceRegion"];
            ownerId?: components["schemas"]["InstanceOwnerId"];
            /** @description Group roleIds that are allowed to join if the type is "group" and groupAccessType is "member" */
            roleIds?: components["schemas"]["GroupRoleID"][];
            groupAccessType?: components["schemas"]["GroupAccessType"];
            /** @default false */
            queueEnabled: boolean;
            /**
             * Format: date-time
             * @description The time after which users won't be allowed to join the instance. This doesn't work for public instances.
             */
            closedAt?: string;
            /**
             * @description Only applies to invite type instances to make them invite+
             * @default false
             */
            canRequestInvite: boolean;
            /**
             * @description Currently unused, but will eventually be a flag to set if the closing of the instance should kick people.
             * @default false
             */
            hardClose: boolean;
            /** @default false */
            inviteOnly: boolean;
        };
        /**
         * Region
         * @description API/Photon region.
         * @default us
         * @example eu
         * @enum {string}
         */
        Region: "us" | "use" | "usw" | "eu" | "jp" | "unknown";
        /** InstancePlatforms */
        InstancePlatforms: {
            /** @example 1 */
            android: number;
            /** @example 5 */
            standalonewindows: number;
        };
        /**
         * Instance
         * @description * `hidden` field is only present if InstanceType is `hidden` aka "Friends+", and is instance creator.
         *     * `friends` field is only present if InstanceType is `friends` aka "Friends", and is instance creator.
         *     * `private` field is only present if InstanceType is `private` aka "Invite" or "Invite+", and is instance creator.
         */
        Instance: {
            /**
             * @default true
             * @example true
             */
            active: boolean;
            /**
             * @default true
             * @example true
             */
            canRequestInvite: boolean;
            /** @example 8 */
            capacity: number;
            /**
             * @deprecated
             * @description Always returns "unknown".
             */
            clientNumber: string;
            /** @default false */
            full: boolean;
            id: components["schemas"]["InstanceID"];
            /** @example 12345~hidden(usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469)~region(eu)~nonce(27e8414a-59a0-4f3d-af1f-f27557eb49a2) */
            instanceId: string;
            location: components["schemas"]["InstanceID"];
            /** @example 6 */
            n_users: number;
            /** @example 12345 */
            name: string;
            ownerId?: components["schemas"]["InstanceOwnerId"];
            /** @default false */
            permanent: boolean;
            photonRegion: components["schemas"]["Region"];
            platforms: components["schemas"]["InstancePlatforms"];
            region: components["schemas"]["InstanceRegion"];
            /** @example 7eavhhng */
            secureName: string;
            /** @example 02u7yz8j */
            shortName?: string | null;
            /**
             * @description The tags array on Instances usually contain the language tags of the people in the instance.
             * @example [
             *       "show_social_rank",
             *       "language_eng",
             *       "language_jpn"
             *     ]
             */
            tags: components["schemas"]["Tag"][];
            type: components["schemas"]["InstanceType"];
            worldId: components["schemas"]["WorldID"];
            hidden?: components["schemas"]["UserID"];
            friends?: components["schemas"]["UserID"];
            private?: components["schemas"]["UserID"];
            queueEnabled: boolean;
            /** @example 6 */
            queueSize: number;
            /** @example 6 */
            recommendedCapacity: number;
            roleRestricted?: boolean;
            strict: boolean;
            /** @example 6 */
            userCount: number;
            world: components["schemas"]["World"];
            /** @description The users field is present on instances created by the requesting user. */
            users?: components["schemas"]["LimitedUser"][];
            groupAccessType?: components["schemas"]["GroupAccessType"];
            hasCapacityForYou?: boolean;
            nonce?: string;
            /** Format: date-time */
            closedAt?: string | null;
            hardClose?: boolean | null;
        };
        /** InstanceShortNameResponse */
        InstanceShortNameResponse: {
            /** @example 7eavhhng */
            secureName: string;
            /** @example 02u7yz8j */
            shortName?: string;
        };
        /**
         * PermissionID
         * @example prms_804ba021-9f47-4e25-9847-1f42fdb2e6ff
         */
        PermissionID: string;
        /** Permission */
        Permission: {
            id: components["schemas"]["PermissionID"];
            ownerDisplayName: string;
            /** @example permission-invite-photos */
            name: string;
            ownerId: components["schemas"]["UserID"];
            data?: Record<string, never>;
        };
        /**
         * PlayerModerationID
         * @example pmod_25551a8d-6f5d-430a-88d3-9c0ce08b5244
         */
        PlayerModerationID: string;
        /**
         * PlayerModerationType
         * @default unmute
         * @example unmute
         * @enum {string}
         */
        PlayerModerationType: "mute" | "unmute" | "block" | "unblock" | "interactOn" | "interactOff";
        /** PlayerModeration */
        PlayerModeration: {
            /** Format: date-time */
            created: string;
            id: components["schemas"]["PlayerModerationID"];
            sourceDisplayName: string;
            sourceUserId: components["schemas"]["UserID"];
            targetDisplayName: string;
            targetUserId: components["schemas"]["UserID"];
            type: components["schemas"]["PlayerModerationType"];
        };
        /** ModerateUserRequest */
        ModerateUserRequest: {
            moderated: components["schemas"]["UserID"];
            type: components["schemas"]["PlayerModerationType"];
        };
        /**
         * APIConfigAnnouncement
         * @deprecated
         * @description Public Announcement
         */
        APIConfigAnnouncement: {
            /** @description Announcement name */
            name: string;
            /** @description Announcement text */
            text: string;
        };
        /**
         * DeploymentGroup
         * @description Used to identify which API deployment cluster is currently responding.
         *
         *     `blue` and `green` are used by Production.
         *     `grape`and `cherry` are used during Development.
         *
         *     [Blue Green Deployment by Martin Fowler](https://martinfowler.com/bliki/BlueGreenDeployment.html)
         * @default blue
         * @enum {string}
         */
        DeploymentGroup: "blue" | "green" | "grape" | "cherry";
        /**
         * APIConfigDownloadURLList
         * @description Download links for various development assets.
         */
        APIConfigDownloadURLList: {
            /**
             * @deprecated
             * @description Download link for legacy SDK2
             */
            sdk2: string;
            /** @description Download link for SDK3 for Avatars */
            "sdk3-avatars": string;
            /** @description Download link for SDK3 for Worlds */
            "sdk3-worlds": string;
            /** @description Download link for the Creator Companion */
            vcc: string;
            /** @description Download link for ??? */
            bootstrap: string;
        };
        /** DynamicContentRow */
        DynamicContentRow: {
            index?: number;
            name: string;
            /** @description Usually "ThisPlatformSupported", but can also be other values such as "all" or platform specific identifiers. */
            platform: string;
            sortHeading: string;
            sortOrder: string;
            sortOwnership: string;
            /** @description Tag to filter content for this row. */
            tag?: string;
            /**
             * @description Type is not present if it is a world.
             * @example avatar
             */
            type?: string;
        };
        /** APIConfigEvents */
        APIConfigEvents: {
            /** @description Unknown */
            distanceClose: number;
            /** @description Unknown */
            distanceFactor: number;
            /** @description Unknown */
            distanceFar: number;
            /** @description Unknown */
            groupDistance: number;
            /** @description Unknown */
            maximumBunchSize: number;
            /** @description Unknown */
            notVisibleFactor: number;
            /** @description Unknown */
            playerOrderBucketSize: number;
            /** @description Unknown */
            playerOrderFactor: number;
            /** @description Unknown */
            slowUpdateFactorThreshold: number;
            /** @description Unknown */
            viewSegmentLength: number;
        };
        /** APIConfig */
        APIConfig: {
            /**
             * @description Unknown, probably voice optimization testing
             * @default false
             */
            VoiceEnableDegradation: boolean;
            /**
             * @description Unknown, probably voice optimization testing
             * @default true
             */
            VoiceEnableReceiverLimiting: boolean;
            /** @description VRChat's office address */
            address: string;
            /** @description Public Announcements */
            announcements: components["schemas"]["APIConfigAnnouncement"][];
            /**
             * @deprecated
             * @description Game name
             * @default VrChat
             */
            appName: string;
            /** @description List of supported Languages */
            availableLanguageCodes: string[];
            /** @description List of supported Languages */
            availableLanguages: string[];
            /** @description Build tag of the API server */
            buildVersionTag: string;
            /** @description apiKey to be used for all other requests */
            clientApiKey: string;
            /**
             * @description Unknown
             * @default 18432
             */
            clientBPSCeiling: number;
            /**
             * @description Unknown
             * @default 30000
             */
            clientDisconnectTimeout: number;
            /**
             * @description Unknown
             * @default false
             */
            clientNetDispatchThread: boolean;
            /**
             * @description Unknown
             * @default false
             */
            clientNetInThread: boolean;
            /**
             * @description Unknown
             * @default false
             */
            clientNetInThread2: boolean;
            /**
             * @description Unknown
             * @default false
             */
            clientNetInThreadMobile: boolean;
            /**
             * @description Unknown
             * @default false
             */
            clientNetInThreadMobile2: boolean;
            /**
             * @description Unknown
             * @default false
             */
            clientNetOutThread: boolean;
            /**
             * @description Unknown
             * @default false
             */
            clientNetOutThread2: boolean;
            /**
             * @description Unknown
             * @default false
             */
            clientNetOutThreadMobile: boolean;
            /**
             * @description Unknown
             * @default false
             */
            clientNetOutThreadMobile2: boolean;
            /**
             * @description Unknown
             * @default 1
             */
            clientQR: number;
            /**
             * @description Unknown
             * @default 7168
             */
            clientReservedPlayerBPS: number;
            /**
             * @description Unknown
             * @default 15
             */
            clientSentCountAllowance: number;
            /** @description VRChat's contact email */
            contactEmail: string;
            /** @description VRChat's copyright-issues-related email */
            copyrightEmail: string;
            /**
             * @description Current version number of the Privacy Agreement
             * @default 1
             */
            currentPrivacyVersion: number;
            /**
             * @description Current version number of the Terms of Service
             * @example 7
             */
            currentTOSVersion: number;
            defaultAvatar: components["schemas"]["AvatarID"];
            deploymentGroup: components["schemas"]["DeploymentGroup"];
            /** @description Unknown */
            devLanguageCodes?: string[];
            /**
             * @deprecated
             * @description Link to download the development SDK, use downloadUrls instead
             */
            devSdkUrl: string;
            /**
             * @deprecated
             * @description Version of the development SDK
             */
            devSdkVersion: string;
            /**
             * Format: date-time
             * @description Unknown, "dis" maybe for disconnect?
             */
            "dis-countdown": string;
            /**
             * @description Unknown
             * @default false
             */
            disableAVProInProton: boolean;
            /**
             * @description Toggles if copying avatars should be disabled
             * @default false
             */
            disableAvatarCopying: boolean;
            /**
             * @description Toggles if avatar gating should be disabled. Avatar gating restricts uploading of avatars to people with the `system_avatar_access` Tag or `admin_avatar_access` Tag
             * @default false
             */
            disableAvatarGating: boolean;
            /**
             * @description Toggles if the Community Labs should be disabled
             * @default false
             */
            disableCommunityLabs: boolean;
            /**
             * @description Toggles if promotion out of Community Labs should be disabled
             * @default false
             */
            disableCommunityLabsPromotion: boolean;
            /**
             * @description Unknown
             * @default false
             */
            disableEmail: boolean;
            /**
             * @description Unknown
             * @default true
             */
            disableCaptcha: boolean;
            /**
             * @description Toggles if Analytics should be disabled.
             * @default false
             */
            disableEventStream: boolean;
            /**
             * @description Toggles if feedback gating should be disabled. Feedback gating restricts submission of feedback (reporting a World or User) to people with the `system_feedback_access` Tag.
             * @default false
             */
            disableFeedbackGating: boolean;
            /**
             * @description Unknown, probably toggles compilation of frontend web builds? So internal flag?
             * @default false
             */
            disableFrontendBuilds: boolean;
            /**
             * @description Unknown
             * @default false
             */
            disableHello: boolean;
            /**
             * @description Toggles if signing up for Subscriptions in Oculus is disabled or not.
             * @default false
             */
            disableOculusSubs: boolean;
            /**
             * @description Toggles if new user account registration should be disabled.
             * @default false
             */
            disableRegistration: boolean;
            /**
             * @description Toggles if Steam Networking should be disabled. VRChat these days uses Photon Unity Networking (PUN) instead.
             * @default true
             */
            disableSteamNetworking: boolean;
            /**
             * @deprecated
             * @description Toggles if 2FA should be disabled.
             * @default false
             */
            disableTwoFactorAuth: boolean;
            /**
             * @description Toggles if Udon should be universally disabled in-game.
             * @default false
             */
            disableUdon: boolean;
            /**
             * @description Toggles if account upgrading "linking with Steam/Oculus" should be disabled.
             * @default false
             */
            disableUpgradeAccount: boolean;
            /** @description Download link for game on the Oculus Rift website. */
            downloadLinkWindows: string;
            downloadUrls: components["schemas"]["APIConfigDownloadURLList"];
            /** @description Array of DynamicWorldRow objects, used by the game to display the list of world rows */
            dynamicWorldRows: components["schemas"]["DynamicContentRow"][];
            /** @description Unknown */
            economyPauseEnd?: string;
            /** @description Unknown */
            economyPauseStart?: string;
            /**
             * @description Unknown
             * @default 1
             */
            economyState: number;
            events: components["schemas"]["APIConfigEvents"];
            homeWorldId: components["schemas"]["WorldID"];
            /**
             * @description Redirect target if you try to open the base API domain in your browser
             * @default https://hello.vrchat.com
             */
            homepageRedirectTarget: string;
            hubWorldId: components["schemas"]["WorldID"];
            /** @description A list of explicitly allowed origins that worlds can request images from via the Udon's [VRCImageDownloader#DownloadImage](https://creators.vrchat.com/worlds/udon/image-loading/#downloadimage). */
            imageHostUrlList: string[];
            /** @description VRChat's job application email */
            jobsEmail: string;
            /** @description VRChat's moderation related email */
            moderationEmail: string;
            /** @description Used in-game to notify a user they aren't allowed to select avatars in private worlds */
            notAllowedToSelectAvatarInPrivateWorldMessage: string;
            /** @description Link to the developer FAQ */
            sdkDeveloperFaqUrl: string;
            /** @description Link to the official VRChat Discord */
            sdkDiscordUrl: string;
            /** @description Used in the SDK to notify a user they aren't allowed to upload avatars/worlds yet */
            sdkNotAllowedToPublishMessage: string;
            /** @description Unity version supported by the SDK */
            sdkUnityVersion: string;
            /** @description Server name of the API server currently responding */
            serverName: string;
            /** @description A list of explicitly allowed origins that worlds can request strings from via the Udon's [VRCStringDownloader.LoadUrl](https://creators.vrchat.com/worlds/udon/string-loading/#ivrcstringdownload). */
            stringHostUrlList: string[];
            /** @description VRChat's support email */
            supportEmail: string;
            timeOutWorldId: components["schemas"]["WorldID"];
            tutorialWorldId: components["schemas"]["WorldID"];
            /** @description Unknown */
            updateRateMsMaximum: number;
            /** @description Unknown */
            updateRateMsMinimum: number;
            /** @description Unknown */
            updateRateMsNormal: number;
            /** @description Unknown */
            updateRateMsUdonManual: number;
            /** @description Unknown */
            uploadAnalysisPercent: number;
            /** @description List of allowed URLs that bypass the "Allow untrusted URL's" setting in-game */
            urlList: string[];
            /**
             * @description Unknown
             * @default false
             */
            useReliableUdpForVoice: boolean;
            /** @description Download link for game on the Steam website. */
            viveWindowsUrl: string;
            /** @description List of allowed URLs that are allowed to host avatar assets */
            whiteListedAssetUrls: string[];
            /** @description Currently used youtube-dl.exe version */
            "player-url-resolver-version": string;
            /** @description Currently used youtube-dl.exe hash in SHA1-delimited format */
            "player-url-resolver-sha1": string;
        };
        /** InfoPushDataClickable */
        InfoPushDataClickable: {
            /**
             * @example OpenURL
             * @enum {string}
             */
            command: "OpenURL" | "OpenVRCPlusMenu" | "OpenSafetyMenu" | "CannedWorldSearch";
            /** @description In case of OpenURL, this would contain the link. */
            parameters?: string[];
        };
        /** InfoPushDataArticleContent */
        InfoPushDataArticleContent: {
            text?: string;
            imageUrl?: string;
            onPressed?: components["schemas"]["InfoPushDataClickable"];
        };
        /** InfoPushDataArticle */
        InfoPushDataArticle: {
            content?: components["schemas"]["InfoPushDataArticleContent"];
        };
        /** InfoPushData */
        InfoPushData: {
            contentList?: components["schemas"]["DynamicContentRow"];
            description?: string;
            imageUrl?: string;
            name?: string;
            onPressed?: components["schemas"]["InfoPushDataClickable"];
            template?: string;
            /** @example 2021.3.4 */
            version?: string;
            article?: components["schemas"]["InfoPushDataArticle"];
        };
        /** InfoPush */
        InfoPush: {
            /** @example launch-beta */
            id: string;
            /** @default true */
            isEnabled: boolean;
            releaseStatus: components["schemas"]["ReleaseStatus"];
            priority: number;
            /** @description   */
            tags: components["schemas"]["Tag"][];
            data: components["schemas"]["InfoPushData"];
            /** @description Unknown usage, MD5 */
            hash: string;
            /** Format: date-time */
            createdAt: string;
            /** Format: date-time */
            updatedAt: string;
            /** Format: date-time */
            startDate?: string;
            /** Format: date-time */
            endDate?: string;
        };
        /** APIHealth */
        APIHealth: {
            ok: boolean;
            serverName: string;
            buildVersionTag: string;
        };
        /** User */
        User: {
            /** @default true */
            allowAvatarCopying: boolean;
            /** @description   */
            badges?: components["schemas"]["Badge"][];
            bio: string;
            bioLinks: string[];
            currentAvatarImageUrl: components["schemas"]["CurrentAvatarImageUrl"];
            currentAvatarThumbnailImageUrl: components["schemas"]["CurrentAvatarThumbnailImageUrl"];
            currentAvatarTags: components["schemas"]["Tag"][];
            /** Format: date */
            date_joined: string;
            developerType: components["schemas"]["DeveloperType"];
            /** @description A users visual display name. This is what shows up in-game, and can different from their `username`. Changing display name is restricted to a cooldown period. */
            displayName: string;
            friendKey: string;
            friendRequestStatus?: string;
            id: components["schemas"]["UserID"];
            instanceId?: components["schemas"]["InstanceID"];
            /** @description Either their `friendKey`, or empty string if you are not friends. Unknown usage. */
            isFriend: boolean;
            /** @description Either a date-time or empty string. */
            last_activity: string;
            /** @description Either a date-time or empty string. */
            last_login: string;
            last_platform: components["schemas"]["Platform"];
            location?: components["schemas"]["WorldID"];
            note?: string;
            platform: string;
            profilePicOverride: string;
            profilePicOverrideThumbnail: string;
            pronouns: string;
            state: components["schemas"]["UserState"];
            status: components["schemas"]["UserStatus"];
            statusDescription: string;
            /** @description   */
            tags: components["schemas"]["Tag"][];
            travelingToInstance?: string;
            travelingToLocation?: string;
            travelingToWorld?: string;
            userIcon: string;
            /**
             * @deprecated
             * @description -| A users unique name, used during login. This is different from `displayName` which is what shows up in-game. A users `username` can never be changed.'
             *     **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
             */
            username?: string;
            worldId?: components["schemas"]["WorldID"];
        };
        /** UpdateUserRequest */
        UpdateUserRequest: {
            email?: string;
            /** Format: date */
            birthday?: string;
            acceptedTOSVersion?: number;
            /** @description   */
            tags?: components["schemas"]["Tag"][];
            status?: components["schemas"]["UserStatus"];
            statusDescription?: string;
            bio?: string;
            bioLinks?: string[];
            pronouns?: string;
            isBoopingEnabled?: boolean;
            /**
             * @description MUST be a valid VRChat /file/ url.
             * @example https://vrchat.com/api/1/file/file_76dc2964-0ce8-41df-b2e7-8edf994fee31/1
             */
            userIcon?: string;
        };
        /** LimitedUserGroups */
        LimitedUserGroups: {
            id?: components["schemas"]["GroupMemberID"];
            name?: string;
            shortCode?: components["schemas"]["GroupShortCode"];
            discriminator?: components["schemas"]["GroupDiscriminator"];
            description?: string;
            iconId?: string | null;
            iconUrl?: string | null;
            bannerId?: string | null;
            bannerUrl?: string | null;
            privacy?: string;
            /** Format: date-time */
            lastPostCreatedAt?: string | null;
            ownerId?: components["schemas"]["UserID"];
            memberCount?: number;
            groupId?: components["schemas"]["GroupID"];
            memberVisibility?: string;
            isRepresenting?: boolean;
            mutualGroup?: boolean;
            /** Format: date-time */
            lastPostReadAt?: string | null;
        };
        /** RepresentedGroup */
        representedGroup: {
            name?: string;
            shortCode?: components["schemas"]["GroupShortCode"];
            discriminator?: components["schemas"]["GroupDiscriminator"];
            description?: string;
            iconId?: string | null;
            iconUrl?: string | null;
            bannerId?: string | null;
            bannerUrl?: string | null;
            privacy?: components["schemas"]["GroupPrivacy"];
            ownerId?: components["schemas"]["UserID"];
            memberCount?: number;
            groupId?: components["schemas"]["GroupID"];
            memberVisibility?: components["schemas"]["GroupUserVisibility"];
            isRepresenting?: boolean;
        };
        /** LimitedUnityPackage */
        LimitedUnityPackage: {
            platform: components["schemas"]["Platform"];
            /** @example 2022.3.6f1 */
            unityVersion: string;
        };
        /** LimitedWorld */
        LimitedWorld: {
            authorId: components["schemas"]["UserID"];
            authorName: string;
            /** @example 8 */
            capacity: number;
            /** @example 16 */
            recommendedCapacity?: number;
            /** Format: date-time */
            created_at: string;
            /**
             * @default 0
             * @example 12024
             */
            favorites: number;
            /**
             * @default 0
             * @example 9988675
             */
            visits: number;
            /**
             * @default 0
             * @example 5
             */
            heat: number;
            id: components["schemas"]["WorldID"];
            imageUrl: string;
            /** @example none */
            labsPublicationDate: string;
            name: string;
            /**
             * @default 0
             * @example 47
             */
            occupants: number;
            /** @default vrchat */
            organization: string;
            /**
             * @default 0
             * @example 8
             */
            popularity: number;
            previewYoutubeId?: string | null;
            /** @example none */
            publicationDate: string;
            releaseStatus: components["schemas"]["ReleaseStatus"];
            /** @description   */
            tags: components["schemas"]["Tag"][];
            thumbnailImageUrl: string;
            /** @description   */
            unityPackages: components["schemas"]["LimitedUnityPackage"][];
            /** Format: date-time */
            updated_at: string;
            udonProducts?: components["schemas"]["UdonProductId"][];
        };
        /** CreateWorldRequest */
        CreateWorldRequest: {
            assetUrl: string;
            assetVersion?: number;
            authorId?: components["schemas"]["UserID"];
            authorName?: string;
            /** @example 8 */
            capacity?: number;
            description?: string;
            id?: components["schemas"]["WorldID"];
            imageUrl: string;
            name: string;
            platform?: components["schemas"]["Platform"];
            releaseStatus?: components["schemas"]["ReleaseStatus"];
            /** @description   */
            tags?: components["schemas"]["Tag"][];
            unityPackageUrl?: string;
            /**
             * @default 5.3.4p1
             * @example 2022.3.6f1
             */
            unityVersion: string;
        };
        /** UpdateWorldRequest */
        UpdateWorldRequest: {
            assetUrl?: string;
            assetVersion?: string;
            authorId?: components["schemas"]["UserID"];
            authorName?: string;
            /** @example 8 */
            capacity?: number;
            description?: string;
            imageUrl?: string;
            name?: string;
            platform?: components["schemas"]["Platform"];
            releaseStatus?: components["schemas"]["ReleaseStatus"];
            /** @description   */
            tags?: components["schemas"]["Tag"][];
            unityPackageUrl?: string;
            /**
             * @default 5.3.4p1
             * @example 2022.3.6f1
             */
            unityVersion: string;
        };
        /** WorldMetadata */
        WorldMetadata: {
            id: components["schemas"]["WorldID"];
            metadata: Record<string, never>;
        };
        /** WorldPublishStatus */
        WorldPublishStatus: {
            /** @default true */
            canPublish: boolean;
        };
        /** NotificationDetailInvite */
        NotificationDetailInvite: {
            inviteMessage?: string;
            worldId: components["schemas"]["WorldID"];
            worldName: string;
        };
        /** NotificationDetailInviteResponse */
        NotificationDetailInviteResponse: {
            inResponseTo: components["schemas"]["NotificationID"];
            responseMessage: string;
        };
        /** NotificationDetailRequestInvite */
        NotificationDetailRequestInvite: {
            /** @description TODO: Does this still exist? */
            platform?: string;
            /** @description Used when using InviteMessage Slot. */
            requestMessage?: string;
        };
        /** NotificationDetailRequestInviteResponse */
        NotificationDetailRequestInviteResponse: {
            inResponseTo: components["schemas"]["NotificationID"];
            /** @description Used when using InviteMessage Slot. */
            requestMessage?: string;
        };
        /** NotificationDetailVoteToKick */
        NotificationDetailVoteToKick: {
            initiatorUserId: components["schemas"]["UserID"];
            userToKickId: components["schemas"]["UserID"];
        };
    };
    responses: {
        /** @description Returns a response if a user exists or not. */
        UserExistsResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["UserExists"];
            };
        };
        /** @description Error response when missing at least 1 of the required parameters. */
        MissingParameterError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description OK */
        CurrentUserLoginResponse: {
            headers: {
                /** @description Successful authentication returns an `auth` cookie. */
                "Set-Cookie"?: string;
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["CurrentUser"];
            };
        };
        /** @description Error response due to missing auth cookie. */
        MissingCredentialsError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description OK */
        Verify2FAResponse: {
            headers: {
                /** @description Provides a `twoFactorAuth` cookie, which can be used to bypasses the 2FA requirement for future logins on the same device. */
                "Set-Cookie"?: string;
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Verify2FAResult"];
            };
        };
        /** @description OK */
        Verify2FAEmailCodeResponse: {
            headers: {
                /** @description Provides a `twoFactorAuth` cookie, which can be used to bypasses the 2FA requirement for future logins on the same device. */
                "Set-Cookie"?: string;
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Verify2FAEmailCodeResult"];
            };
        };
        /** @description Returns wether a provided auth token is valid or not. */
        VerifyAuthTokenResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["VerifyAuthTokenResult"];
            };
        };
        /** @description OK */
        LogoutSuccess: {
            headers: {
                /** @description Clears the `auth` cookie. */
                "Set-Cookie"?: string;
                /** @description Clears the `age` cookie. */
                "\\0Set-Cookie"?: string;
                /** @description Clears the `tos` cookie. */
                "\\0\\0Set-Cookie"?: string;
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Success"];
            };
        };
        /** @description OK */
        DeleteUserResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["CurrentUser"];
            };
        };
        /** @description Returns a single Avatar object. */
        AvatarResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Avatar"];
            };
        };
        /** @description Error response when trying to see another users current avatar without sufficient admin permissions. */
        AvatarSeeOtherUserCurrentAvatarError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Returns a list of Avatar objects. */
        AvatarListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Avatar"][];
            };
        };
        /** @description Error response when set featured to true without being an admin. */
        FeaturedSetNotAdminError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Error response when trying to show information about a non-existent avatar. */
        AvatarNotFoundError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Returns a single CurrentUser object. */
        CurrentUserResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["CurrentUser"];
            };
        };
        /** @description Error response when trying to select a fallback avatar that is missing the fallback tag. */
        AvatarNotTaggedAsFallbackError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Error response when trying to see favourited avatars of another user without sufficient admin permissions. */
        AvatarSeeOtherUserFavoritesError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Returns a list of Transaction objects. */
        TransactionListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Transaction"][];
            };
        };
        /** @description Returns a single Transaction object. */
        TransactionResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Transaction"];
            };
        };
        /** @description Returns a list of UserSubscription objects. */
        UserSubscriptionListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["UserSubscription"][];
            };
        };
        /** @description Returns a list of Subscription objects. */
        SubscriptionListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Subscription"][];
            };
        };
        /** @description Returns a list of LicenseGroup objects. */
        LicenseGroupListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["LicenseGroup"][];
            };
        };
        /** @description Returns a single LicenseGroup object. */
        LicenseGroupResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["LicenseGroup"];
            };
        };
        /** @description Returns a list of Favorite objects. */
        FavoriteListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Favorite"][];
            };
        };
        /** @description Returns a single Favorite object. */
        FavoriteResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Favorite"];
            };
        };
        /** @description Error response when trying favorite someone or something when already having it/them favorited. */
        FavoriteAddAlreadyFavoritedError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Error response when trying favorite someone whom you are not friends with. */
        FavoriteAddNotFriendsError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Error response when trying to show information about a non-existent favorite. */
        FavoriteNotFoundError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Success response after removing a favorite. */
        FavoriteRemovedSuccess: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Success"];
            };
        };
        /** @description Returns a list of FavoriteGroup objects. */
        FavoriteGroupListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["FavoriteGroup"][];
            };
        };
        /** @description Returns a single FavoriteGroup object. */
        FavoriteGroupResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["FavoriteGroup"];
            };
        };
        /** @description Success response after clearing a favorite group. */
        FavoriteGroupClearedSuccess: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Success"];
            };
        };
        /** @description Returns a list of File objects. */
        FileListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["File"][];
            };
        };
        /** @description Returns a single File object. */
        FileResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["File"];
            };
        };
        /** @description Error response when trying to show information about a non-existent file. */
        FileNotFoundError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Error response when trying to delete a non-existent file. */
        FileDeletedError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Raw file */
        RawFileResponse: {
            headers: {
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description Error response when trying to delete the initial version of a file. Delete the main File object instead. */
        FileVersionDeleteInitialError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Error response when trying to delete any version of a file that is not the last one. */
        FileVersionDeleteMiddleError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description See [https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutObject.html](AWS REST docs - PUT Object) */
        FileUploadURLResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["FileUploadURL"];
            };
        };
        /** @description Error response when trying to start an upload against a FileVersion that is already marked as  `complete`. */
        FileUploadAlreadyFinishedError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Current FileVersion upload status. Contains the uploadId needed for uploading, as well as the already uploaded parts. */
        FileVersionUploadStatusResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["FileVersionUploadStatus"];
            };
        };
        /** @description Returns a list of LimitedUser objects. */
        LimitedUserListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["LimitedUser"][];
            };
        };
        /** @description Returns a single Notifcation object. */
        NotificationResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Notification"];
            };
        };
        /** @description Bad request error response when sending a friend request */
        FriendBadRequestError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Error response when trying to send a friend request to a user which doesn't exist. */
        UserDoesntExistError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Successful response after cancelling a friend request. */
        DeleteFriendSuccess: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Success"];
            };
        };
        /** @description Error response when trying to delete a non-existent friend-request. */
        DeleteFriendRequestError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Returns a users Friend Status. */
        FriendStatusResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["FriendStatus"];
            };
        };
        /** @description Successful response after unfriending a user. */
        UnfriendSuccess: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Success"];
            };
        };
        /** @description Error response when trying to unfriend someone who is not a friend. */
        NotFriendsError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Returns a list of LimitedGroup objects. */
        LimitedGroupListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["LimitedGroup"][];
            };
        };
        /** @description Returns a single Group object. */
        GroupResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Group"];
            };
        };
        /** @description Error response when trying to perform operations on a non-existing group. */
        GroupNotFoundError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Successful response after deleting a Group. */
        DeleteGroupSuccess: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Success"];
            };
        };
        /** @description Returns a single GroupAnnouncement object. */
        GroupAnnouncementResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GroupAnnouncement"];
            };
        };
        /** @description Successful response after deleting/clearing the group announcement. */
        DeleteGroupAnnouncementSuccess: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Success"];
            };
        };
        /** @description Returns a list of GroupAudit objects, wrapped in new pagination format. */
        GroupAuditLogListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["PaginatedGroupAuditLogEntryList"];
            };
        };
        /** @description Returns a list of GroupMember objects. */
        GroupMemberListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GroupMember"][];
            };
        };
        /** @description Error response due to missing permissions. */
        NoPermission: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Returns a list of GroupMember objects. */
        GroupMemberResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GroupMember"];
            };
        };
        /** @description Bad request error response when banning a user */
        BanGroupMemberBadRequestError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Returns a single GroupGallery object. */
        GroupGalleryResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GroupGallery"];
            };
        };
        /** @description Returns a list of GroupGalleryImage objects. */
        GroupGalleryImageListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GroupGalleryImage"][];
            };
        };
        /** @description Successful response after deleting a group gallery. */
        DeleteGroupGallerySuccess: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Success"];
            };
        };
        /** @description Returns a single GroupGalleryImage object. */
        GroupGalleryImageResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GroupGalleryImage"];
            };
        };
        /** @description Successful response after deleting a group gallery image. */
        DeleteGroupGalleryImageSuccess: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Success"];
            };
        };
        /** @description Error response when trying to delete a submission to a group's gallery when the user does not have permission to do so. */
        GroupGalleryImageDeleteForbiddenError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Returns a list of GroupInstance objects. */
        GroupInstanceListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GroupInstance"][];
            };
        };
        /** @description Error response when trying to perform operations on a group you are not member of. */
        GroupNotMemberError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Bad request error response when creating a group invite. */
        GroupInviteBadRequestError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Forbidden error response when creating a group invite. */
        GroupInviteForbiddenError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Bad request error response when deleting a group invite */
        DeleteGroupInviteBadRequestError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Error response when trying to join a group that the user is already a member of. */
        GroupAlreadyMemberError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Error response when trying to search list of users with an invalid request. */
        UsersInvalidSearchError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Returns a list of GroupMember objects. */
        GroupLimitedMemberResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GroupLimitedMember"];
            };
        };
        /** @description Returns a list of GroupRoleID objects. */
        GroupRoleIDListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GroupRoleIDList"];
            };
        };
        /** @description Returns a list of GroupPermission objects. */
        GroupPermissionListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GroupPermission"][];
            };
        };
        /** @description Returns a GroupPost object. */
        GroupPostResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GroupPost"];
            };
        };
        /** @description Response after deleting a group post. */
        GroupPostResponseSuccess: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Success"];
            };
        };
        /** @description Bad request error response when responding to a group join request */
        GroupJoinRequestResponseBadRequestError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Returns a list of GroupRole objects. */
        GroupRoleListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GroupRole"][];
            };
        };
        /** @description Returns a single GroupRole object. */
        GroupRoleResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GroupRole"];
            };
        };
        /** @description Returns a single SentNotifcation object. */
        SendNotificationResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["SentNotification"];
            };
        };
        /** @description Error response when trying to invite someome whom you are not friends with. */
        InviteMustBeFriendsError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Error response due to non existant instance */
        InstanceNotFoundError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Error response when trying to respond to an invite and something went wrong. */
        InviteResponse400Error: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Returns a list of InviteMessage objects. */
        InviteMessageListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["InviteMessage"][];
            };
        };
        /** @description Error response when trying to update an Invite Message with an invalid slot number. */
        InviteMessageInvalidSlotNumberError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Error response due to missing authorization to perform that action. */
        NotAuthorizedActionError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Returns a single InviteMessage object. */
        InviteMessageResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["InviteMessage"];
            };
        };
        /** @description Error response when trying to get an Invite Message with a negative slot number. */
        InviteMessageGetNegativeSlotError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Error response when trying to get an Invite Message with a too high slot number. */
        InviteMessageGetTooHighSlotError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Error response when trying to update an Invite Message before the cooldown has expired. */
        InviteMessageUpdateRateLimitError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Error response when trying to reset an Invite Message whos slot doesn't exist. */
        InviteMessageNoEntryForSlotError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Returns a single Instance object. */
        InstanceResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Instance"];
            };
        };
        /** @description Error response due to not being allowed to close an instance */
        InstanceCloseForbiddenError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Returns an instance secureName and/or shortName. */
        InstanceShortNameResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "text/plain": components["schemas"]["InstanceShortNameResponse"];
            };
        };
        /** @description Success response after sending an invite to yourself to the instance. */
        InstanceSelfInviteSuccess: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Success"];
            };
        };
        /** @description Returns a list of Notifcation objects. */
        NotificationListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Notification"][];
            };
        };
        /** @description Successful response after friending a user. */
        FriendSuccess: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Success"];
            };
        };
        /** @description Error response when trying to accept a non-existent friend request. */
        AcceptFriendRequestError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Successful response after clearing all notifications. */
        ClearNotificationsSuccess: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Success"];
            };
        };
        /** @description Returns a list of Permission objects. */
        PermissionListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Permission"][];
            };
        };
        /** @description Error response due to missing Administrator credentials. */
        InvalidAdminCredentialsError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Returns a single Permission object. */
        PermissionResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Permission"];
            };
        };
        /** @description Returns a list of PlayerModeration objects. */
        PlayerModerationListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["PlayerModeration"][];
            };
        };
        /** @description Returns a single PlayerModeration object. */
        PlayerModerationResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["PlayerModeration"];
            };
        };
        /** @description Success response after e.g. clearing all player moderations. */
        PlayerModerationClearAllSuccess: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Success"];
            };
        };
        /** @description Error response when trying to show information about a non-existent player moderation. */
        PlayerModerationNotFoundError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Success response after removing a PlayerModeration by ID. */
        PlayerModerationRemovedSuccess: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Success"];
            };
        };
        /** @description Error response when trying to delete someone else's player moderation. */
        PlayerModerationDeleteOthersError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Success response after unmoderating a player moderation. */
        PlayerModerationUnmoderatedSuccess: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Success"];
            };
        };
        /** @description Returns the API's config. */
        APIConfigResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["APIConfig"];
            };
        };
        /** @description Returns a list of InfoPush objects. */
        InfoPushListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["InfoPush"][];
            };
        };
        /** @description Error response when trying to download non-public and non-main JavaScript or CSS without Admin Credentials. */
        DownloadSourceCodeAccessError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Returns the API's health. */
        APIHealthResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["APIHealth"];
            };
        };
        /** @description OK */
        CurrentOnlineUsersResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": number;
            };
        };
        /** @description OK */
        SystemTimeResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": string;
            };
        };
        /** @description Returns a single User object. */
        UserResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["User"];
            };
        };
        /** @description Returns a list of LimitedUserGroups objects. */
        LimitedUserGroupListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["LimitedUserGroups"][];
            };
        };
        /** @description Returns a list of Group objects. */
        GroupListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Group"][];
            };
        };
        /** @description Returns a list of LimitedWorld objects. */
        LimitedWorldListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["LimitedWorld"][];
            };
        };
        /** @description Returns a single World object. */
        WorldResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["World"];
            };
        };
        /** @description Error response when trying create a world without having the neccesary Trust rank yet. */
        WorldCreateNotAllowedYetError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Error response when trying to see favourited worlds of another user without sufficient admin permissions. */
        WorldSeeOtherUserFavoritesError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Error response when trying to see recently visited worlds of another user without sufficient admin permissions. */
        WorldSeeOtherUserRecentsError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Error response when trying to show information about a non-existent world. Sometimes returns with `model <worldId> not found` instead of `World <worldId not found`. */
        WorldNotFoundError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description OK */
        WorldMetadataResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["WorldMetadata"];
            };
        };
        /** @description Returns a single WorldPublishStatus object. */
        WorldPublishStatusResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["WorldPublishStatus"];
            };
        };
    };
    parameters: {
        /** @description Filter by email. */
        email: string;
        /** @description Filter by displayName. */
        displayName: string;
        /** @description Filter by Username. */
        usernameQuery: string;
        /** @description Exclude by UserID. */
        excludeUserId: string;
        /** @description Must be a valid user ID. */
        userId: string;
        /** @description Filters on featured results. */
        featured: boolean;
        /** @description The sort order of the results. */
        sort: components["schemas"]["SortOption"];
        /** @description Filter by UserID. */
        userIdQuery: string;
        /** @description The number of objects to return. */
        number: number;
        /** @description Result ordering */
        order: components["schemas"]["OrderOption"];
        /** @description A zero-based offset from the default object sorting from where search results start. */
        offset: number;
        /** @description Tags to include (comma-separated). Any of the tags needs to be present. */
        tag: string;
        /** @description Tags to exclude (comma-separated). */
        notag: string;
        /** @description Filter by ReleaseStatus. */
        releaseStatus: components["schemas"]["ReleaseStatus"];
        /** @description The maximum Unity version supported by the asset. */
        maxUnityVersion: string;
        /** @description The minimum Unity version supported by the asset. */
        minUnityVersion: string;
        /** @description The platform the asset supports. */
        platform: string;
        /** @description Must be a valid avatar ID. */
        avatarId: string;
        /** @description Filters by world name. */
        search: string;
        /** @description Target user to see information on, admin-only. */
        userIdAdmin: string;
        /** @description Must be a valid transaction ID. */
        transactionId: string;
        /** @description Must be a valid license group ID. */
        licenseGroupId: string;
        /** @description Must be a valid favorite ID. */
        favoriteId: string;
        /** @description The type of group to fetch, must be a valid FavoriteType. */
        favoriteGroupType: "world" | "friend" | "avatar";
        /** @description The name of the group to fetch, must be a name of a FavoriteGroup. */
        favoriteGroupName: string;
        /** @description Must be a valid file ID. */
        fileId: string;
        /** @description Version ID of the asset. */
        versionId: number;
        /** @description Type of file. */
        fileType: "file" | "signature" | "delta";
        /** @description Returns *only* offline users if true, returns only online and active users if false */
        offline: boolean;
        /** @description Must be a valid group ID. */
        groupId: string;
        /** @description The start date of the search range. */
        startDate: string;
        /** @description The end date of the search range. */
        endDate: string;
        /** @description Must be a valid group gallery ID. */
        groupGalleryId: string;
        /** @description Must be a valid group gallery image ID. */
        groupGalleryImageId: string;
        /** @description The sort order of Group Member results */
        groupMemberSort: components["schemas"]["GroupSearchSort"];
        /** @description Must be a valid group role ID. */
        groupRoleId: string;
        /** @description Must be a valid notification ID. */
        notificationId: string;
        /** @description Must be a valid world ID. */
        worldId: string;
        /** @description Must be a valid instance ID. */
        instanceId: string;
        /** @description The type of message to fetch, must be a valid InviteMessageType. */
        messageType: components["schemas"]["InviteMessageType"];
        /** @description The message slot to fetch of a given message type. */
        slot: number;
        /** @description Must be a valid permission ID. */
        permissionId: string;
        /** @description Tags to include (comma-separated). All of the tags needs to be present. */
        require: string;
        /** @description Tags to include (comma-separated). Any of the tags needs to be present. */
        include: string;
        /** @description Specifies which `variant` of the site. Public is the end-user site, while `internal` is the staff-only site with special pages for moderation and management. */
        variant: "public" | "internal";
        /** @description Specifies which git branch the site should load frontend source code from. */
        branch: string;
        fuzzy: boolean;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    checkUserExists: {
        parameters: {
            query?: {
                /** @description Filter by email. */
                email?: components["parameters"]["email"];
                /** @description Filter by displayName. */
                displayName?: components["parameters"]["displayName"];
                /** @description Filter by Username. */
                username?: components["parameters"]["usernameQuery"];
                /** @description Exclude by UserID. */
                excludeUserId?: components["parameters"]["excludeUserId"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserExistsResponse"];
            400: components["responses"]["MissingParameterError"];
        };
    };
    getCurrentUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["CurrentUserLoginResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    verify2FA: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TwoFactorAuthCode"];
            };
        };
        responses: {
            200: components["responses"]["Verify2FAResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    verifyRecoveryCode: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TwoFactorAuthCode"];
            };
        };
        responses: {
            200: components["responses"]["Verify2FAResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    verify2FAEmailCode: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TwoFactorEmailCode"];
            };
        };
        responses: {
            200: components["responses"]["Verify2FAEmailCodeResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    verifyAuthToken: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["VerifyAuthTokenResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    logout: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LogoutSuccess"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    deleteUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["DeleteUserResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getOwnAvatar: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["AvatarResponse"];
            401: components["responses"]["MissingCredentialsError"];
            403: components["responses"]["AvatarSeeOtherUserCurrentAvatarError"];
        };
    };
    searchAvatars: {
        parameters: {
            query?: {
                /** @description Filters on featured results. */
                featured?: components["parameters"]["featured"];
                /** @description The sort order of the results. */
                sort?: components["parameters"]["sort"];
                /** @description Set to `me` for searching own avatars. */
                user?: "me";
                /** @description Filter by UserID. */
                userId?: components["parameters"]["userIdQuery"];
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description Result ordering */
                order?: components["parameters"]["order"];
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
                /** @description Tags to include (comma-separated). Any of the tags needs to be present. */
                tag?: components["parameters"]["tag"];
                /** @description Tags to exclude (comma-separated). */
                notag?: components["parameters"]["notag"];
                /** @description Filter by ReleaseStatus. */
                releaseStatus?: components["parameters"]["releaseStatus"];
                /** @description The maximum Unity version supported by the asset. */
                maxUnityVersion?: components["parameters"]["maxUnityVersion"];
                /** @description The minimum Unity version supported by the asset. */
                minUnityVersion?: components["parameters"]["minUnityVersion"];
                /** @description The platform the asset supports. */
                platform?: components["parameters"]["platform"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["AvatarListResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    createAvatar: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateAvatarRequest"];
            };
        };
        responses: {
            200: components["responses"]["AvatarResponse"];
            401: components["responses"]["FeaturedSetNotAdminError"];
        };
    };
    getAvatar: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid avatar ID. */
                avatarId: components["parameters"]["avatarId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["AvatarResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["AvatarNotFoundError"];
        };
    };
    updateAvatar: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid avatar ID. */
                avatarId: components["parameters"]["avatarId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UpdateAvatarRequest"];
            };
        };
        responses: {
            200: components["responses"]["AvatarResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["AvatarNotFoundError"];
        };
    };
    deleteAvatar: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid avatar ID. */
                avatarId: components["parameters"]["avatarId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["AvatarResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["AvatarNotFoundError"];
        };
    };
    selectAvatar: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid avatar ID. */
                avatarId: components["parameters"]["avatarId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["CurrentUserResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["AvatarNotFoundError"];
        };
    };
    selectFallbackAvatar: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid avatar ID. */
                avatarId: components["parameters"]["avatarId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["CurrentUserResponse"];
            401: components["responses"]["MissingCredentialsError"];
            403: components["responses"]["AvatarNotTaggedAsFallbackError"];
            404: components["responses"]["AvatarNotFoundError"];
        };
    };
    getFavoritedAvatars: {
        parameters: {
            query?: {
                /** @description Filters on featured results. */
                featured?: components["parameters"]["featured"];
                /** @description The sort order of the results. */
                sort?: components["parameters"]["sort"];
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description Result ordering */
                order?: components["parameters"]["order"];
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
                /** @description Filters by world name. */
                search?: components["parameters"]["search"];
                /** @description Tags to include (comma-separated). Any of the tags needs to be present. */
                tag?: components["parameters"]["tag"];
                /** @description Tags to exclude (comma-separated). */
                notag?: components["parameters"]["notag"];
                /** @description Filter by ReleaseStatus. */
                releaseStatus?: components["parameters"]["releaseStatus"];
                /** @description The maximum Unity version supported by the asset. */
                maxUnityVersion?: components["parameters"]["maxUnityVersion"];
                /** @description The minimum Unity version supported by the asset. */
                minUnityVersion?: components["parameters"]["minUnityVersion"];
                /** @description The platform the asset supports. */
                platform?: components["parameters"]["platform"];
                /** @description Target user to see information on, admin-only. */
                userId?: components["parameters"]["userIdAdmin"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["AvatarListResponse"];
            401: components["responses"]["MissingCredentialsError"];
            403: components["responses"]["AvatarSeeOtherUserFavoritesError"];
        };
    };
    getSteamTransactions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["TransactionListResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getSteamTransaction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid transaction ID. */
                transactionId: components["parameters"]["transactionId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["TransactionResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getCurrentSubscriptions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserSubscriptionListResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getSubscriptions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["SubscriptionListResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getLicenseGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid license group ID. */
                licenseGroupId: components["parameters"]["licenseGroupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LicenseGroupResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getFavorites: {
        parameters: {
            query?: {
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
                /** @description The type of favorites to return, FavoriteType. */
                type?: string;
                /** @description Tags to include (comma-separated). Any of the tags needs to be present. */
                tag?: components["parameters"]["tag"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["FavoriteListResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    addFavorite: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["AddFavoriteRequest"];
            };
        };
        responses: {
            200: components["responses"]["FavoriteResponse"];
            400: components["responses"]["FavoriteAddAlreadyFavoritedError"];
            403: components["responses"]["FavoriteAddNotFriendsError"];
        };
    };
    getFavorite: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid favorite ID. */
                favoriteId: components["parameters"]["favoriteId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["FavoriteResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["FavoriteNotFoundError"];
        };
    };
    removeFavorite: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid favorite ID. */
                favoriteId: components["parameters"]["favoriteId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["FavoriteRemovedSuccess"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["FavoriteNotFoundError"];
        };
    };
    getFavoriteGroups: {
        parameters: {
            query?: {
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
                /** @description The owner of whoms favorite groups to return. Must be a UserID. */
                ownerId?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["FavoriteGroupListResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getFavoriteGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The type of group to fetch, must be a valid FavoriteType. */
                favoriteGroupType: components["parameters"]["favoriteGroupType"];
                /** @description The name of the group to fetch, must be a name of a FavoriteGroup. */
                favoriteGroupName: components["parameters"]["favoriteGroupName"];
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["FavoriteGroupResponse"];
        };
    };
    updateFavoriteGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The type of group to fetch, must be a valid FavoriteType. */
                favoriteGroupType: components["parameters"]["favoriteGroupType"];
                /** @description The name of the group to fetch, must be a name of a FavoriteGroup. */
                favoriteGroupName: components["parameters"]["favoriteGroupName"];
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UpdateFavoriteGroupRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    clearFavoriteGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The type of group to fetch, must be a valid FavoriteType. */
                favoriteGroupType: components["parameters"]["favoriteGroupType"];
                /** @description The name of the group to fetch, must be a name of a FavoriteGroup. */
                favoriteGroupName: components["parameters"]["favoriteGroupName"];
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["FavoriteGroupClearedSuccess"];
        };
    };
    getFiles: {
        parameters: {
            query?: {
                /** @description Tag, for example "icon" or "gallery", not included by default. */
                tag?: string;
                /**
                 * @deprecated
                 * @description UserID, will always generate a 500 permission error.
                 */
                userId?: string;
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["FileListResponse"];
        };
    };
    createFile: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateFileRequest"];
            };
        };
        responses: {
            200: components["responses"]["FileResponse"];
        };
    };
    getFile: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid file ID. */
                fileId: components["parameters"]["fileId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["FileResponse"];
            404: components["responses"]["FileNotFoundError"];
        };
    };
    createFileVersion: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid file ID. */
                fileId: components["parameters"]["fileId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateFileVersionRequest"];
            };
        };
        responses: {
            200: components["responses"]["FileResponse"];
        };
    };
    deleteFile: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid file ID. */
                fileId: components["parameters"]["fileId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["FileResponse"];
            404: components["responses"]["FileDeletedError"];
        };
    };
    downloadFileVersion: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid file ID. */
                fileId: components["parameters"]["fileId"];
                /** @description Version ID of the asset. */
                versionId: components["parameters"]["versionId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RawFileResponse"];
            404: components["responses"]["FileNotFoundError"];
        };
    };
    deleteFileVersion: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid file ID. */
                fileId: components["parameters"]["fileId"];
                /** @description Version ID of the asset. */
                versionId: components["parameters"]["versionId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["FileResponse"];
            400: components["responses"]["FileVersionDeleteInitialError"];
            500: components["responses"]["FileVersionDeleteMiddleError"];
        };
    };
    finishFileDataUpload: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid file ID. */
                fileId: components["parameters"]["fileId"];
                /** @description Version ID of the asset. */
                versionId: components["parameters"]["versionId"];
                /** @description Type of file. */
                fileType: components["parameters"]["fileType"];
            };
            cookie?: never;
        };
        /** @description Please see documentation on ETag's:
         *     [https://teppen.io/2018/06/23/aws_s3_etags/](https://teppen.io/2018/06/23/aws_s3_etags/)
         *
         *     ETag's should NOT be present when uploading a `signature`. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["FinishFileDataUploadRequest"];
            };
        };
        responses: {
            200: components["responses"]["FileResponse"];
        };
    };
    startFileDataUpload: {
        parameters: {
            query?: {
                /**
                 * @deprecated
                 * @description The part number to start uploading. If not provided, the first part will be started.
                 */
                partNumber?: number;
            };
            header?: never;
            path: {
                /** @description Must be a valid file ID. */
                fileId: components["parameters"]["fileId"];
                /** @description Version ID of the asset. */
                versionId: components["parameters"]["versionId"];
                /** @description Type of file. */
                fileType: components["parameters"]["fileType"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["FileUploadURLResponse"];
            400: components["responses"]["FileUploadAlreadyFinishedError"];
        };
    };
    getFileDataUploadStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid file ID. */
                fileId: components["parameters"]["fileId"];
                /** @description Version ID of the asset. */
                versionId: components["parameters"]["versionId"];
                /** @description Type of file. */
                fileType: components["parameters"]["fileType"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["FileVersionUploadStatusResponse"];
        };
    };
    getFriends: {
        parameters: {
            query?: {
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description Returns *only* offline users if true, returns only online and active users if false */
                offline?: components["parameters"]["offline"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LimitedUserListResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    friend: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["NotificationResponse"];
            400: components["responses"]["FriendBadRequestError"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["UserDoesntExistError"];
        };
    };
    deleteFriendRequest: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["DeleteFriendSuccess"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["DeleteFriendRequestError"];
        };
    };
    getFriendStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["FriendStatusResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    unfriend: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UnfriendSuccess"];
            400: components["responses"]["NotFriendsError"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    searchGroups: {
        parameters: {
            query?: {
                /** @description Query to search for, can be either Group Name or Group shortCode */
                query?: string;
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LimitedGroupListResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    createGroup: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateGroupRequest"];
            };
        };
        responses: {
            200: components["responses"]["GroupResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getGroup: {
        parameters: {
            query?: {
                /** @description Include roles for the Group object. Defaults to false. */
                includeRoles?: boolean;
            };
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    updateGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UpdateGroupRequest"];
            };
        };
        responses: {
            200: components["responses"]["GroupResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    deleteGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["DeleteGroupSuccess"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    getGroupAnnouncements: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupAnnouncementResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    createGroupAnnouncement: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateGroupAnnouncementRequest"];
            };
        };
        responses: {
            200: components["responses"]["GroupAnnouncementResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    deleteGroupAnnouncement: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["DeleteGroupAnnouncementSuccess"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    getGroupAuditLogs: {
        parameters: {
            query?: {
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
                /** @description The start date of the search range. */
                startDate?: components["parameters"]["startDate"];
                /** @description The end date of the search range. */
                endDate?: components["parameters"]["endDate"];
            };
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupAuditLogListResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    getGroupBans: {
        parameters: {
            query?: {
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
            };
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupMemberListResponse"];
            401: components["responses"]["MissingCredentialsError"];
            403: components["responses"]["NoPermission"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    banGroupMember: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BanGroupMemberRequest"];
            };
        };
        responses: {
            200: components["responses"]["GroupMemberResponse"];
            400: components["responses"]["BanGroupMemberBadRequestError"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    unbanGroupMember: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupMemberResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    createGroupGallery: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateGroupGalleryRequest"];
            };
        };
        responses: {
            200: components["responses"]["GroupGalleryResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    getGroupGalleryImages: {
        parameters: {
            query?: {
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
                /** @description If specified, only returns images that have been approved or not approved. */
                approved?: boolean;
            };
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid group gallery ID. */
                groupGalleryId: components["parameters"]["groupGalleryId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupGalleryImageListResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    updateGroupGallery: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid group gallery ID. */
                groupGalleryId: components["parameters"]["groupGalleryId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UpdateGroupGalleryRequest"];
            };
        };
        responses: {
            200: components["responses"]["GroupGalleryResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    deleteGroupGallery: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid group gallery ID. */
                groupGalleryId: components["parameters"]["groupGalleryId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["DeleteGroupGallerySuccess"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    addGroupGalleryImage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid group gallery ID. */
                groupGalleryId: components["parameters"]["groupGalleryId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AddGroupGalleryImageRequest"];
            };
        };
        responses: {
            200: components["responses"]["GroupGalleryImageResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    deleteGroupGalleryImage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid group gallery ID. */
                groupGalleryId: components["parameters"]["groupGalleryId"];
                /** @description Must be a valid group gallery image ID. */
                groupGalleryImageId: components["parameters"]["groupGalleryImageId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["DeleteGroupGalleryImageSuccess"];
            401: components["responses"]["MissingCredentialsError"];
            403: components["responses"]["GroupGalleryImageDeleteForbiddenError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    getGroupInstances: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupInstanceListResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    getGroupInvites: {
        parameters: {
            query?: {
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
            };
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupMemberListResponse"];
            401: components["responses"]["MissingCredentialsError"];
            403: components["responses"]["GroupNotMemberError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    createGroupInvite: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateGroupInviteRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["GroupInviteBadRequestError"];
            401: components["responses"]["MissingCredentialsError"];
            403: components["responses"]["GroupInviteForbiddenError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    deleteGroupInvite: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["DeleteGroupInviteBadRequestError"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    joinGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupMemberResponse"];
            400: components["responses"]["GroupAlreadyMemberError"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    leaveGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            403: components["responses"]["GroupNotMemberError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    getGroupMembers: {
        parameters: {
            query?: {
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
                /** @description The sort order of Group Member results */
                sort?: components["parameters"]["groupMemberSort"];
            };
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupMemberListResponse"];
            400: components["responses"]["UsersInvalidSearchError"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    getGroupMember: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupLimitedMemberResponse"];
            401: components["responses"]["MissingCredentialsError"];
            403: components["responses"]["GroupNotMemberError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    updateGroupMember: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UpdateGroupMemberRequest"];
            };
        };
        responses: {
            200: components["responses"]["GroupLimitedMemberResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    kickGroupMember: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["MissingCredentialsError"];
            403: components["responses"]["GroupNotMemberError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    addGroupMemberRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
                /** @description Must be a valid group role ID. */
                groupRoleId: components["parameters"]["groupRoleId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupRoleIDListResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    removeGroupMemberRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
                /** @description Must be a valid group role ID. */
                groupRoleId: components["parameters"]["groupRoleId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupRoleIDListResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    getGroupPermissions: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupPermissionListResponse"];
            400: components["responses"]["UsersInvalidSearchError"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    getGroupPost: {
        parameters: {
            query?: {
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
                /** @description See public posts only. */
                publicOnly?: boolean;
            };
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupPostResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    addGroupPost: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateGroupPostRequest"];
            };
        };
        responses: {
            200: components["responses"]["GroupPostResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    updateGroupPost: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid notification ID. */
                notificationId: components["parameters"]["notificationId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateGroupPostRequest"];
            };
        };
        responses: {
            200: components["responses"]["GroupPostResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupPostResponseSuccess"];
        };
    };
    deleteGroupPost: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid notification ID. */
                notificationId: components["parameters"]["notificationId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupPostResponseSuccess"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupPostResponseSuccess"];
        };
    };
    getGroupRequests: {
        parameters: {
            query?: {
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
                /** @description See blocked join requests */
                blocked?: boolean;
            };
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupMemberListResponse"];
            400: components["responses"]["GroupJoinRequestResponseBadRequestError"];
            403: components["responses"]["GroupNotMemberError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    cancelGroupRequest: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description You can't cancel a join request if you didn't request to join․ */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            403: components["responses"]["GroupNotMemberError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    respondGroupJoinRequest: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RespondGroupJoinRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    getGroupRoles: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupRoleListResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    createGroupRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateGroupRoleRequest"];
            };
        };
        responses: {
            200: components["responses"]["GroupRoleResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotFoundError"];
        };
    };
    updateGroupRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid group role ID. */
                groupRoleId: components["parameters"]["groupRoleId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UpdateGroupRoleRequest"];
            };
        };
        responses: {
            200: components["responses"]["GroupRoleListResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    deleteGroupRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid group ID. */
                groupId: components["parameters"]["groupId"];
                /** @description Must be a valid group role ID. */
                groupRoleId: components["parameters"]["groupRoleId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupRoleListResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["GroupNotMemberError"];
        };
    };
    inviteUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        /** @description Slot number of the Invite Message to use when inviting a user. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["InviteRequest"];
            };
        };
        responses: {
            200: components["responses"]["SendNotificationResponse"];
            403: components["responses"]["InviteMustBeFriendsError"];
        };
    };
    inviteMyselfTo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
                /** @description Must be a valid instance ID. */
                instanceId: components["parameters"]["instanceId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["SendNotificationResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["InstanceNotFoundError"];
        };
    };
    requestInvite: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        /** @description Slot number of the Request Message to use when request an invite. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RequestInviteRequest"];
            };
        };
        responses: {
            200: components["responses"]["NotificationResponse"];
            403: components["responses"]["InviteMustBeFriendsError"];
        };
    };
    respondInvite: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid notification ID. */
                notificationId: components["parameters"]["notificationId"];
            };
            cookie?: never;
        };
        /** @description Slot number of the Response Message to use when responding to a user. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["InviteResponse"];
            };
        };
        responses: {
            200: components["responses"]["NotificationResponse"];
            400: components["responses"]["InviteResponse400Error"];
        };
    };
    getInviteMessages: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
                /** @description The type of message to fetch, must be a valid InviteMessageType. */
                messageType: components["parameters"]["messageType"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["InviteMessageListResponse"];
            400: components["responses"]["InviteMessageInvalidSlotNumberError"];
            401: components["responses"]["NotAuthorizedActionError"];
        };
    };
    getInviteMessage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
                /** @description The type of message to fetch, must be a valid InviteMessageType. */
                messageType: components["parameters"]["messageType"];
                /** @description The message slot to fetch of a given message type. */
                slot: components["parameters"]["slot"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["InviteMessageResponse"];
            400: components["responses"]["InviteMessageGetNegativeSlotError"];
            401: components["responses"]["NotAuthorizedActionError"];
            404: components["responses"]["InviteMessageGetTooHighSlotError"];
        };
    };
    updateInviteMessage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
                /** @description The type of message to fetch, must be a valid InviteMessageType. */
                messageType: components["parameters"]["messageType"];
                /** @description The message slot to fetch of a given message type. */
                slot: components["parameters"]["slot"];
            };
            cookie?: never;
        };
        /** @description Message of what to set the invite message to. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UpdateInviteMessageRequest"];
            };
        };
        responses: {
            200: components["responses"]["InviteMessageListResponse"];
            400: components["responses"]["InviteMessageInvalidSlotNumberError"];
            401: components["responses"]["NotAuthorizedActionError"];
            429: components["responses"]["InviteMessageUpdateRateLimitError"];
        };
    };
    resetInviteMessage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
                /** @description The type of message to fetch, must be a valid InviteMessageType. */
                messageType: components["parameters"]["messageType"];
                /** @description The message slot to fetch of a given message type. */
                slot: components["parameters"]["slot"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["InviteMessageListResponse"];
            400: components["responses"]["InviteMessageInvalidSlotNumberError"];
            401: components["responses"]["NotAuthorizedActionError"];
            404: components["responses"]["InviteMessageNoEntryForSlotError"];
            429: components["responses"]["InviteMessageUpdateRateLimitError"];
        };
    };
    createInstance: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateInstanceRequest"];
            };
        };
        responses: {
            200: components["responses"]["InstanceResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getInstance: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
                /** @description Must be a valid instance ID. */
                instanceId: components["parameters"]["instanceId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["InstanceResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    closeInstance: {
        parameters: {
            query?: {
                /** @description Whether to hard close the instance. Defaults to false. */
                hardClose?: boolean;
                /** @description The time after which users won't be allowed to join the instances.
                 *     If omitted, the instance will be closed immediately. */
                closedAt?: string;
            };
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
                /** @description Must be a valid instance ID. */
                instanceId: components["parameters"]["instanceId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["InstanceResponse"];
            401: components["responses"]["MissingCredentialsError"];
            403: components["responses"]["InstanceCloseForbiddenError"];
            404: components["responses"]["InstanceNotFoundError"];
        };
    };
    getShortName: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
                /** @description Must be a valid instance ID. */
                instanceId: components["parameters"]["instanceId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["InstanceShortNameResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    sendSelfInvite: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
                /** @description Must be a valid instance ID. */
                instanceId: components["parameters"]["instanceId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["InstanceSelfInviteSuccess"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getInstanceByShortName: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid instance short name. */
                shortName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["InstanceResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["InstanceNotFoundError"];
        };
    };
    getNotifications: {
        parameters: {
            query?: {
                /**
                 * @deprecated
                 * @description Only send notifications of this type (can use `all` for all). This parameter no longer does anything, and is deprecated.
                 */
                type?: string;
                /**
                 * @deprecated
                 * @description Return notifications sent by the user. Must be false or omitted.
                 */
                sent?: boolean;
                /** @description Whether to return hidden or non-hidden notifications. True only allowed on type `friendRequest`. */
                hidden?: boolean;
                /** @description Only return notifications sent after this Date. Ignored if type is `friendRequest`. */
                after?: string;
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["NotificationListResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    acceptFriendRequest: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid notification ID. */
                notificationId: components["parameters"]["notificationId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["FriendSuccess"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["AcceptFriendRequestError"];
        };
    };
    markNotificationAsRead: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid notification ID. */
                notificationId: components["parameters"]["notificationId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["NotificationResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    deleteNotification: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid notification ID. */
                notificationId: components["parameters"]["notificationId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["NotificationResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    clearNotifications: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ClearNotificationsSuccess"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getAssignedPermissions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PermissionListResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getPermission: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid permission ID. */
                permissionId: components["parameters"]["permissionId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PermissionResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getPlayerModerations: {
        parameters: {
            query?: {
                /** @description Must be one of PlayerModerationType, except unblock. Unblocking simply removes a block. */
                type?: string;
                /** @description Must be valid UserID. */
                targetUserId?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PlayerModerationListResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    moderateUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ModerateUserRequest"];
            };
        };
        responses: {
            200: components["responses"]["PlayerModerationResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    clearAllPlayerModerations: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PlayerModerationClearAllSuccess"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getPlayerModeration: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid `pmod_` ID. */
                playerModerationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PlayerModerationResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["PlayerModerationNotFoundError"];
        };
    };
    deletePlayerModeration: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid `pmod_` ID. */
                playerModerationId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["PlayerModerationRemovedSuccess"];
            401: components["responses"]["MissingCredentialsError"];
            403: components["responses"]["PlayerModerationDeleteOthersError"];
        };
    };
    unmoderateUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ModerateUserRequest"];
            };
        };
        responses: {
            200: components["responses"]["PlayerModerationUnmoderatedSuccess"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getConfig: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["APIConfigResponse"];
        };
    };
    getInfoPush: {
        parameters: {
            query?: {
                /** @description Tags to include (comma-separated). All of the tags needs to be present. */
                require?: components["parameters"]["require"];
                /** @description Tags to include (comma-separated). Any of the tags needs to be present. */
                include?: components["parameters"]["include"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["InfoPushListResponse"];
        };
    };
    getCSS: {
        parameters: {
            query?: {
                /** @description Specifies which `variant` of the site. Public is the end-user site, while `internal` is the staff-only site with special pages for moderation and management. */
                variant?: components["parameters"]["variant"];
                /** @description Specifies which git branch the site should load frontend source code from. */
                branch?: components["parameters"]["branch"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description **Note:** VRChat uses 302 Redirect to Cloudfront. The implementing library **must** support and follow redirects natively. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/css": string;
                };
            };
            400: components["responses"]["DownloadSourceCodeAccessError"];
        };
    };
    getJavaScript: {
        parameters: {
            query?: {
                /** @description Specifies which `variant` of the site. Public is the end-user site, while `internal` is the staff-only site with special pages for moderation and management. */
                variant?: components["parameters"]["variant"];
                /** @description Specifies which git branch the site should load frontend source code from. */
                branch?: components["parameters"]["branch"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description **Note:** VRChat uses 302 Redirect to Cloudfront. The implementing library **must** support and follow redirects natively. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/javascript": string;
                };
            };
            400: components["responses"]["DownloadSourceCodeAccessError"];
        };
    };
    getHealth: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["APIHealthResponse"];
        };
    };
    getCurrentOnlineUsers: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["CurrentOnlineUsersResponse"];
        };
    };
    getSystemTime: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["SystemTimeResponse"];
        };
    };
    searchUsers: {
        parameters: {
            query?: {
                /** @description Searches by `displayName`. Will return empty array if search query is empty or missing. */
                search?: string;
                /** @description Active user by developer type, none for normal users and internal for moderators */
                developerType?: string;
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LimitedUserListResponse"];
            400: components["responses"]["UsersInvalidSearchError"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getUserByName: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Username of the user */
                username: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["UserResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    updateUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UpdateUserRequest"];
            };
        };
        responses: {
            200: components["responses"]["CurrentUserResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getUserGroups: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LimitedUserGroupListResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getUserGroupRequests: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GroupListResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getUserRepresentedGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid user ID. */
                userId: components["parameters"]["userId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["representedGroup"];
                };
            };
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    searchWorlds: {
        parameters: {
            query?: {
                /** @description Filters on featured results. */
                featured?: components["parameters"]["featured"];
                /** @description The sort order of the results. */
                sort?: components["parameters"]["sort"];
                /** @description Set to `me` for searching own worlds. */
                user?: "me";
                /** @description Filter by UserID. */
                userId?: components["parameters"]["userIdQuery"];
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description Result ordering */
                order?: components["parameters"]["order"];
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
                /** @description Filters by world name. */
                search?: components["parameters"]["search"];
                /** @description Tags to include (comma-separated). Any of the tags needs to be present. */
                tag?: components["parameters"]["tag"];
                /** @description Tags to exclude (comma-separated). */
                notag?: components["parameters"]["notag"];
                /** @description Filter by ReleaseStatus. */
                releaseStatus?: components["parameters"]["releaseStatus"];
                /** @description The maximum Unity version supported by the asset. */
                maxUnityVersion?: components["parameters"]["maxUnityVersion"];
                /** @description The minimum Unity version supported by the asset. */
                minUnityVersion?: components["parameters"]["minUnityVersion"];
                /** @description The platform the asset supports. */
                platform?: components["parameters"]["platform"];
                fuzzy?: components["parameters"]["fuzzy"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LimitedWorldListResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    createWorld: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateWorldRequest"];
            };
        };
        responses: {
            200: components["responses"]["WorldResponse"];
            400: components["responses"]["WorldCreateNotAllowedYetError"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getActiveWorlds: {
        parameters: {
            query?: {
                /** @description Filters on featured results. */
                featured?: components["parameters"]["featured"];
                /** @description The sort order of the results. */
                sort?: components["parameters"]["sort"];
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description Result ordering */
                order?: components["parameters"]["order"];
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
                /** @description Filters by world name. */
                search?: components["parameters"]["search"];
                /** @description Tags to include (comma-separated). Any of the tags needs to be present. */
                tag?: components["parameters"]["tag"];
                /** @description Tags to exclude (comma-separated). */
                notag?: components["parameters"]["notag"];
                /** @description Filter by ReleaseStatus. */
                releaseStatus?: components["parameters"]["releaseStatus"];
                /** @description The maximum Unity version supported by the asset. */
                maxUnityVersion?: components["parameters"]["maxUnityVersion"];
                /** @description The minimum Unity version supported by the asset. */
                minUnityVersion?: components["parameters"]["minUnityVersion"];
                /** @description The platform the asset supports. */
                platform?: components["parameters"]["platform"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LimitedWorldListResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
    getFavoritedWorlds: {
        parameters: {
            query?: {
                /** @description Filters on featured results. */
                featured?: components["parameters"]["featured"];
                /** @description The sort order of the results. */
                sort?: components["parameters"]["sort"];
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description Result ordering */
                order?: components["parameters"]["order"];
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
                /** @description Filters by world name. */
                search?: components["parameters"]["search"];
                /** @description Tags to include (comma-separated). Any of the tags needs to be present. */
                tag?: components["parameters"]["tag"];
                /** @description Tags to exclude (comma-separated). */
                notag?: components["parameters"]["notag"];
                /** @description Filter by ReleaseStatus. */
                releaseStatus?: components["parameters"]["releaseStatus"];
                /** @description The maximum Unity version supported by the asset. */
                maxUnityVersion?: components["parameters"]["maxUnityVersion"];
                /** @description The minimum Unity version supported by the asset. */
                minUnityVersion?: components["parameters"]["minUnityVersion"];
                /** @description The platform the asset supports. */
                platform?: components["parameters"]["platform"];
                /** @description Target user to see information on, admin-only. */
                userId?: components["parameters"]["userIdAdmin"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LimitedWorldListResponse"];
            401: components["responses"]["MissingCredentialsError"];
            403: components["responses"]["WorldSeeOtherUserFavoritesError"];
        };
    };
    getRecentWorlds: {
        parameters: {
            query?: {
                /** @description Filters on featured results. */
                featured?: components["parameters"]["featured"];
                /** @description The sort order of the results. */
                sort?: components["parameters"]["sort"];
                /** @description The number of objects to return. */
                n?: components["parameters"]["number"];
                /** @description Result ordering */
                order?: components["parameters"]["order"];
                /** @description A zero-based offset from the default object sorting from where search results start. */
                offset?: components["parameters"]["offset"];
                /** @description Filters by world name. */
                search?: components["parameters"]["search"];
                /** @description Tags to include (comma-separated). Any of the tags needs to be present. */
                tag?: components["parameters"]["tag"];
                /** @description Tags to exclude (comma-separated). */
                notag?: components["parameters"]["notag"];
                /** @description Filter by ReleaseStatus. */
                releaseStatus?: components["parameters"]["releaseStatus"];
                /** @description The maximum Unity version supported by the asset. */
                maxUnityVersion?: components["parameters"]["maxUnityVersion"];
                /** @description The minimum Unity version supported by the asset. */
                minUnityVersion?: components["parameters"]["minUnityVersion"];
                /** @description The platform the asset supports. */
                platform?: components["parameters"]["platform"];
                /** @description Target user to see information on, admin-only. */
                userId?: components["parameters"]["userIdAdmin"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["LimitedWorldListResponse"];
            401: components["responses"]["MissingCredentialsError"];
            403: components["responses"]["WorldSeeOtherUserRecentsError"];
        };
    };
    getWorld: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WorldResponse"];
            404: components["responses"]["WorldNotFoundError"];
        };
    };
    updateWorld: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UpdateWorldRequest"];
            };
        };
        responses: {
            200: components["responses"]["WorldResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["WorldNotFoundError"];
        };
    };
    deleteWorld: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["WorldNotFoundError"];
        };
    };
    getWorldMetadata: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WorldMetadataResponse"];
            404: components["responses"]["WorldNotFoundError"];
        };
    };
    getWorldPublishStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["WorldPublishStatusResponse"];
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["WorldNotFoundError"];
        };
    };
    publishWorld: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description TODO */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["WorldNotFoundError"];
        };
    };
    unpublishWorld: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["MissingCredentialsError"];
            404: components["responses"]["WorldNotFoundError"];
        };
    };
    getWorldInstance: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Must be a valid world ID. */
                worldId: components["parameters"]["worldId"];
                /** @description Must be a valid instance ID. */
                instanceId: components["parameters"]["instanceId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["InstanceResponse"];
            401: components["responses"]["MissingCredentialsError"];
        };
    };
}
